<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP/IP网络编程 学习笔记]]></title>
    <url>%2F2019%2F11%2F29%2FTCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《TCP/IP网络编程》学习笔记:flags: 转自《TCP/IP网络编程》 第 1 章：理解网络编程和套接字本章代码，在TCP-IP-NetworkNote中可以找到，直接点连接可能进不去。 1.1 理解网络编程和套接字1.1.1构建打电话套接字以电话机打电话的方式来理解套接字。 调用 socket 函数（安装电话机）时进行的对话： 问：接电话需要准备什么？ 答：当然是电话机。 有了电话机才能安装电话，于是就要准备一个电话机，下面函数相当于电话机的套接字。 123#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);//成功时返回文件描述符，失败时返回-1 调用 bind 函数（分配电话号码）时进行的对话： 问：请问我的电话号码是多少 答：我的电话号码是123-1234 套接字同样如此。就想给电话机分配电话号码一样，利用以下函数给创建好的套接字分配地址信息（IP地址和端口号）： 123#include &lt;sys/socket.h&gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);//成功时返回0，失败时返回-1 调用 bind 函数给套接字分配地址之后，就基本完成了所有的准备工作。接下来是需要连接电话线并等待来电。 调用 listen 函数（连接电话线）时进行的对话： 问：已架设完电话机后是否只需链接电话线？ 答：对，只需要连接就能接听电话。 一连接电话线，电话机就可以转换为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接受连接状态。 123#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);//成功时返回0，失败时返回-1 连接好电话线以后，如果有人拨打电话就响铃，拿起话筒才能接听电话。 调用 accept 函数（拿起话筒）时进行的对话： 问：电话铃响了，我该怎么办？ 答：接听啊。 123#include &lt;sys/socket.h&gt;int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);//成功时返回文件描述符，失败时返回-1 网络编程中和接受连接请求的套接字创建过程可整理如下： 第一步：调用 socket 函数创建套接字。 第二步：调用 bind 函数分配IP地址和端口号。 第三步：调用 listen 函数转换为可接受请求状态。 第四步：调用 accept 函数受理套接字请求。 1.1.2 编写Hello World套接字程序服务端： 服务器端（server）是能够受理连接请求的程序。下面构建服务端以验证之前提到的函数调用过程，该服务器端收到连接请求后向请求者返回Hello World!答复。除各种函数的调用顺序外，我们还未涉及任何实际编程。因此，阅读代码时请重点关注套接字相关的函数调用过程，不必理解全过程。 服务器端代码请参见：hello_server.c 客户端： 客户端程序只有调用 socket 函数创建套接字 和 调用 connect 函数向服务端发送连接请求这两个步骤，下面给出客户端，需要查看以下两方面的内容： 调用 socket 函数 和 connect 函数 与服务端共同运行以收发字符串数据 客户端代码请参见：hello_client.c 编译： 分别对客户端和服务端程序进行编译： 12gcc hello_server.c -o hservergcc hello_client.c -o hclient 运行： 12./hserver 9190./hclient 127.0.0.1 9190 运行的时候，首先再 9190 端口启动服务，然后 heserver 就会一直等待客户端进行响应，当客户端监听位于本地的 IP 为 127.0.0.1 的地址的9190端口时，客户端就会收到服务端的回应，输出Hello World! 1.2 基于 Linux 的文件操作讨论套接字的过程中突然谈及文件也许有些奇怪。但是对于 Linux 而言，socket 操作与文件操作没有区别，因而有必要详细了解文件。在 Linux 世界里，socket 也被认为是文件的一种，因此在网络数据传输过程中自然可以使用 I/O 的相关函数。Windows 与 Linux 不同，是要区分 socket 和文件的。因此在 Windows 中需要调用特殊的数据传输相关函数。 1.2.1 底层访问和文件描述符分配给标准输入输出及标准错误的文件描述符。 文件描述符 对象 0 标准输入：Standard Input 1 标准输出：Standard Output 2 标准错误：Standard Error 文件和套接字一般经过创建过程才会被分配文件描述符。 文件描述符也被称为「文件句柄」，但是「句柄」主要是 Windows 中的术语。因此，在本书中如果设计 Windows 平台将使用「句柄」，如果是 Linux 将使用「描述符」。 1.2.2 打开文件:123456789#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *path, int flag);/*成功时返回文件描述符，失败时返回-1path : 文件名的字符串地址flag : 文件打开模式信息*/ 文件打开模式如下表： 打开模式 含义 O_CREAT 必要时创建文件 O_TRUNC 删除全部现有数据 O_APPEND 维持现有数据，保存到其后面 O_RDONLY 只读打开 O_WRONLY 只写打开 O_RDWR 读写打开 1.2.3 关闭文件：123456#include &lt;unistd.h&gt;int close(int fd);/*成功时返回 0 ，失败时返回 -1fd : 需要关闭的文件或套接字的文件描述符*/ 若调用此函数同时传递文件描述符参数，则关闭（终止）响应文件。另外需要注意的是，此函数不仅可以关闭文件，还可以关闭套接字。再次证明了「Linux 操作系统不区分文件与套接字」的特点。 1.2.4 将数据写入文件：12345678#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes);/*成功时返回写入的字节数 ，失败时返回 -1fd : 显示数据传输对象的文件描述符buf : 保存要传输数据的缓冲值地址nbytes : 要传输数据的字节数*/ 在此函数的定义中，size_t 是通过 typedef 声明的 unsigned int 类型。对 ssize_t 来说，ssize_t 前面多加的 s 代表 signed ，即 ssize_t 是通过 typedef 声明的 signed int 类型。 创建新文件并保存数据： 代码见：low_open.c 编译运行： 12gcc low_open.c -o lopen./lopen 然后会生成一个data.txt的文件，里面有Let&#39;s go! 1.2.5 读取文件中的数据：与之前的write()函数相对应，read()用来输入（接收）数据。 12345678#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes);/*成功时返回接收的字节数（但遇到文件结尾则返回 0），失败时返回 -1fd : 显示数据接收对象的文件描述符buf : 要保存接收的数据的缓冲地址值。nbytes : 要接收数据的最大字节数*/ 下面示例通过 read() 函数读取 data.txt 中保存的数据。 代码见：low_read.c 编译运行： 12gcc low_read.c -o lread./lread 在上一步的 data.txt 文件与没有删的情况下，会输出： 12file descriptor: 3file data: Let&apos;s go! 关于文件描述符的 I/O 操作到此结束，要明白，这些内容同样适合于套接字。 1.2.6 文件描述符与套接字下面将同时创建文件和套接字，并用整数型态比较返回的文件描述符的值. 代码见：fd_seri.c 编译运行： 12gcc fd_seri.c -o fds./fds 输出结果: 123file descriptor 1: 3file descriptor 2: 15file descriptor 3: 16 1.3 基于 Windows 平台的实现暂略 1.4 基于 Windows 的套接字相关函数及示例暂略 1.5 习题 :heavy_exclamation_mark:以下部分的答案，仅代表我个人观点，可能不是正确答案 套接字在网络编程中的作用是什么？为何称它为套接字？ 答：操作系统会提供「套接字」（socket）的部件，套接字是网络数据传输用的软件设备。因此，「网络编程」也叫「套接字编程」。「套接字」就是用来连接网络的工具。 在服务器端创建套接字以后，会依次调用 listen 函数和 accept 函数。请比较二者作用。 答：调用 listen 函数将套接字转换成可受连接状态（监听），调用 accept 函数受理连接请求。如果在没有连接请求的情况下调用该函数，则不会返回，直到有连接请求为止。 Linux 中，对套接字数据进行 I/O 时可以直接使用文件 I/O 相关函数；而在 Windows 中则不可以。原因为何？ 答：暂略。 创建套接字后一般会给他分配地址，为什么？为了完成地址分配需要调用哪个函数？ 答：套接字被创建之后，只有为其分配了IP地址和端口号后，客户端才能够通过IP地址及端口号与服务器端建立连接，需要调用 bind 函数来完成地址分配。 Linux 中的文件描述符与 Windows 的句柄实际上非常类似。请以套接字为对象说明它们的含义。 答：暂略。 底层 I/O 函数与 ANSI 标准定义的文件 I/O 函数有何区别？ 答：文件 I/O 又称为低级磁盘 I/O，遵循 POSIX 相关标准。任何兼容 POSIX 标准的操作系统上都支持文件I/O。标准 I/O 被称为高级磁盘 I/O，遵循 ANSI C 相关标准。只要开发环境中有标准 I/O 库，标准 I/O 就可以使用。（Linux 中使用的是 GLIBC，它是标准C库的超集。不仅包含 ANSI C 中定义的函数，还包括 POSIX 标准中定义的函数。因此，Linux 下既可以使用标准 I/O，也可以使用文件 I/O）。 参考本书给出的示例low_open.c和low_read.c，分别利用底层文件 I/O 和 ANSI 标准 I/O 编写文件复制程序。可任意指定复制程序的使用方法。 答：暂略。 第 2 章 套接字类型与协议设置本章代码，在TCP-IP-NetworkNote中可以找到，直接点连接可能进不去。 本章仅需了解创建套接字时调用的 socket 函数。 2.1 套接字协议及数据传输特性2.1.1 创建套接字12345678#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);/*成功时返回文件描述符，失败时返回-1domain: 套接字中使用的协议族（Protocol Family）type: 套接字数据传输的类型信息protocol: 计算机间通信中使用的协议信息*/ 2.1.2 协议族（Protocol Family）通过 socket 函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族，可分成如下几类： 头文件 sys/socket.h 中声明的协议族 名称 协议族 PF_INET IPV4 互联网协议族 PF_INET6 IPV6 互联网协议族 PF_LOCAL 本地通信 Unix 协议族 PF_PACKET 底层套接字的协议族 PF_IPX IPX Novel 协议族 本书着重讲 PF_INET 对应的 IPV4 互联网协议族。其他协议并不常用，或并未普及。另外，套接字中采用的最终的协议信息是通过 socket 函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。 2.1.3 套接字类型（Type）套接字类型指的是套接字的数据传输方式，是通过 socket 函数的第二个参数进行传递，只有这样才能决定创建的套接字的数据传输方式。已经通过第一个参数传递了协议族信息，为什么还要决定数据传输方式？问题就在于，决定了协议族并不能同时决定数据传输方式。换言之， socket 函数的第一个参数 PF_INET 协议族中也存在多种数据传输方式。 2.1.4 套接字类型1：面向连接的套接字（SOCK_STREAM）如果 socket 函数的第二个参数传递SOCK_STREAM，将创建面向连接的套接字。 传输方式特征整理如下： 传输过程中数据不会消失 按序传输数据 传输的数据不存在数据边界（Boundary） 这种情形适用于之前说过的 write 和 read 函数 传输数据的计算机通过调用3次 write 函数传递了 100 字节的数据，但是接受数据的计算机仅仅通过调用 1 次 read 函数调用就接受了全部 100 个字节。 收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。只要不超过数组容量，那么数据填满缓冲后过 1 次 read 函数的调用就可以读取全部，也有可能调用多次来完成读取。 套接字缓冲已满是否意味着数据丢失？ 答：缓冲并不总是满的。如果读取速度比数据传入过来的速度慢，则缓冲可能被填满，但是这时也不会丢失数据，因为传输套接字此时会停止数据传输，所以面向连接的套接字不会发生数据丢失。 套接字联机必须一一对应。面向连接的套接字可总结为： 可靠地、按序传递的、基于字节的面向连接的数据传输方式的套接字。 2.1.5 面向消息的套接字（SOCK_DGRAM）如果 socket 函数的第二个参数传递SOCK_DGRAM，则将创建面向消息的套接字。面向消息的套接字可以比喻成高速移动的摩托车队。特点如下： 强调快速传输而非传输有序 传输的数据可能丢失也可能损毁 传输的数据有边界 限制每次传输数据的大小 面向消息的套接字比面向连接的套接字更具哟传输速度，但可能丢失。特点可总结为： 不可靠的、不按序传递的、以数据的高速传输为目的套接字。 2.1.6 协议的最终选择socket 函数的第三个参数决定最终采用的协议。前面已经通过前两个参数传递了协议族信息和套接字数据传输方式，这些信息还不够吗？为什么要传输第三个参数呢？ 可以应对同一协议族中存在的多个数据传输方式相同的协议，所以数据传输方式相同，但是协议不同，需要用第三个参数指定具体的协议信息。 本书用的是 Ipv4 的协议族，和面向连接的数据传输，满足这两个条件的协议只有 TPPROTO_TCP ，因此可以如下调用 socket 函数创建套接字，这种套接字称为 TCP 套接字。 1int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); SOCK_DGRAM 指的是面向消息的数据传输方式，满足上述条件的协议只有 TPPROTO_UDP 。这种套接字称为 UDP 套接字： 1int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); 2.1.7 面向连接的套接字：TCP 套接字示例需要对第一章的代码做出修改，修改好的代码如下： tcp_client.c tcp_server.c 编译： 12gcc tcp_client.c -o hclientgcc tcp_server.c -o hserver 运行： 12./hserver 9190./hclient 127.0.0.1 9190 结果： 12Message from server : Hello World! Function read call count: 13 从运行结果可以看出服务端发送了13字节的数据，客户端调用13次 read 函数进行读取。 2.2 Windows 平台下的实现及验证暂略 2.3 习题 什么是协议？在收发数据中定义协议有何意义？ 答：协议是对话中使用的通信规则，简言之，协议就是为了完成数据交换而定好的约定。在收发数据中定义协议，能够让计算机之间进行正确无误的对话，以此来交换数据。 面向连接的套接字 TCP 套接字传输特性有 3 点，请分别说明。 答：①传输过程中数据不会消失②按序传输数据③传输的数据不存在数据边界（Boundary） 下面那些是面向消息的套接字的特性？ 传输数据可能丢失 没有数据边界（Boundary） 以快速传递为目标 不限制每次传输数据大小 与面向连接的套接字不同，不存在连接概念 下列数据适合用哪类套接字进行传输？ 演唱会现场直播的多媒体数据（UDP） 某人压缩过的文本文件（TCP） 网上银行用户与银行之间的数据传递（TCP） 何种类型的套接字不存在数据边界？这类套接字接收数据时应该注意什么？ 答：TCP 不存在数据边界。在接收数据时，需要保证在接收套接字的缓冲区填充满之时就从buffer里读取数据。也就是，在接收套接字内部，写入buffer的速度要小于读出buffer的速度。 第 3 章 地址族与数据序列本章代码，在TCP-IP-NetworkNote中可以找到。 把套接字比喻成电话，那么目前只安装了电话机，本章讲解给电话机分配号码的方法，即给套接字分配 IP 地址和端口号。 3.1 分配给套接字的 IP 地址与端口号IP 是 Internet Protocol（网络协议）的简写，是为手法网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为了区分程序中创建的套接字而分配给套接字的端口号。 3.1.1 网络地址（Internet Address）为使计算机连接到网络并收发数据，必须为其分配 IP 地址。IP 地址分为两类。 IPV4（Internet Protocol version 4）4 字节地址族 IPV6（Internet Protocol version 6）6 字节地址族 两者之间的主要差别是 IP 地址所用的字节数，目前通用的是 IPV4 , IPV6 的普及还需要时间。 IPV4 标准的 4 字节 IP 地址分为网络地址和主机（指计算机）地址，且分为 A、B、C、D、E 等类型。 数据传输过程： 某主机向 203.211.172.103 和 203.211.217.202 传递数据，其中 203.211.172 和 203.211.217 为该网络的网络地址，所以「向相应网络传输数据」实际上是向构成网络的路由器或者交换机传输数据，然后又路由器或者交换机根据数据中的主机地址向目标主机传递数据。 3.1.2 网络地址分类与主机地址边界只需通过IP地址的第一个字节即可判断网络地址占用的总字节数，因为我们根据IP地址的边界区分网络地址，如下所示： A 类地址的首字节范围为：0~127 B 类地址的首字节范围为：128~191 C 类地址的首字节范围为：192~223 还有如下这种表示方式： A 类地址的首位以 0 开始 B 类地址的前2位以 10 开始 C 类地址的前3位以 110 开始 因此套接字手法数据时，数据传到网络后即可轻松找到主机。 3.1.3 用于区分套接字的端口号IP地址用于区分计算机，只要有IP地址就能向目标主机传输数据，但是只有这些还不够，我们需要把信息传输给具体的应用程序。 所以计算机一般有 NIC（网络接口卡）数据传输设备。通过 NIC 接受的数据内有端口号，操作系统参考端口号把信息传给相应的应用程序。 端口号由 16 位构成，可分配的端口号范围是 065535 。但是 01023 是知名端口，一般分配给特定的应用程序，所以应当分配给此范围之外的值。 虽然端口号不能重复，但是 TCP 套接字和 UDP 套接字不会共用端接口号，所以允许重复。如果某 TCP 套接字使用了 9190 端口号，其他 TCP 套接字就无法使用该端口号，但是 UDP 套接字可以使用。 总之，数据传输目标地址同时包含IP地址和端口号，只有这样，数据才会被传输到最终的目的应用程序。 3.2 地址信息的表示应用程序中使用的IP地址和端口号以结构体的形式给出了定义。本节围绕结构体讨论目标地址的表示方法。 3.2.1 表示 IPV4 地址的结构体结构体的定义如下 1234567struct sockaddr_in&#123; sa_family_t sin_family; //地址族（Address Family） uint16_t sin_port; //16 位 TCP/UDP 端口号 struct in_addr sin_addr; //32位 IP 地址 char sin_zero[8]; //不使用&#125;; 该结构体中提到的另一个结构体 in_addr 定义如下，它用来存放 32 位IP地址 1234struct in_addr&#123; in_addr_t s_addr; //32位IPV4地址&#125; 关于以上两个结构体的一些数据类型。 数据类型名称 数据类型说明 声明的头文件 int 8_t signed 8-bit int sys/types.h uint8_t unsigned 8-bit int (unsigned char) sys/types.h int16_t signed 16-bit int sys/types.h uint16_t unsigned 16-bit int (unsigned short) sys/types.h int32_t signed 32-bit int sys/types.h uint32_t unsigned 32-bit int (unsigned long) sys/types.h sa_family_t 地址族（address family） sys/socket.h socklen_t 长度（length of struct） sys/socket.h in_addr_t IP地址，声明为 uint_32_t netinet/in.h in_port_t 端口号，声明为 uint_16_t netinet/in.h 为什么要额外定义这些数据类型呢？这是考虑扩展性的结果 3.2.2 结构体 sockaddr_in 的成员分析 成员 sin_family 每种协议适用的地址族不同，比如，IPV4 使用 4 字节的地址族，IPV6 使用 16 字节的地址族。 地址族 地址族（Address Family） 含义 AF_INET IPV4用的地址族 AF_INET6 IPV6用的地址族 AF_LOCAL 本地通信中采用的 Unix 协议的地址族 AF_LOACL 只是为了说明具有多种地址族而添加的。 成员 sin_port 该成员保存 16 位端口号，重点在于，它以网络字节序保存。 成员 sin_addr 该成员保存 32 为IP地址信息，且也以网络字节序保存 成员 sin_zero 无特殊含义。只是为结构体 sockaddr_in 结构体变量地址值将以如下方式传递给 bind 函数。 在之前的代码中 12if (bind(serv_sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) == -1) error_handling("bind() error"); 此处 bind 第二个参数期望得到的是 sockaddr 结构体变量的地址值，包括地址族、端口号、IP地址等。 12345struct sockaddr&#123; sa_family_t sin_family; //地址族 char sa_data[14]; //地址信息&#125; 此结构体 sa_data 保存的地址信息中需要包含IP地址和端口号，剩余部分应该填充 0 ，但是这样对于包含地址的信息非常麻烦，所以出现了 sockaddr_in 结构体，然后强制转换成 sockaddr 类型，则生成符合 bind 条件的参数。 3.3 网络字节序与地址变换不同的 CPU 中，4 字节整数值1在内存空间保存方式是不同的。 有些 CPU 这样保存： 100000000 00000000 00000000 00000001 有些 CPU 这样保存： 100000001 00000000 00000000 00000000 两种一种是顺序保存，一种是倒序保存 。 3.3.1 字节序（Order）与网络字节序CPU 保存数据的方式有两种，这意味着 CPU 解析数据的方式也有 2 种： 大端序（Big Endian）：高位字节存放到低位地址 小端序（Little Endian）：高位字节存放到高位地址 两台字节序不同的计算机在数据传递的过程中可能出现的问题： 因为这种原因，所以在通过网络传输数据时必须约定统一的方式，这种约定被称为网络字节序，非常简单，统一为大端序。即，先把数据数组转化成大端序格式再进行网络传输。 3.3.2 字节序转换帮助转换字节序的函数： 1234unsigned short htons(unsigned short);unsigned short ntohs(unsigned short);unsigned long htonl(unsigned long);unsigned long ntohl(unsigned long); 通过函数名称掌握其功能，只需要了解： htons 的 h 代表主机（host）字节序。 htons 的 n 代表网络（network）字节序。 s 代表 short l 代表 long 下面的代码是示例，说明以上函数调用过程： endian_conv.c 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char *argv[])&#123; unsigned short host_port = 0x1234; unsigned short net_port; unsigned long host_addr = 0x12345678; unsigned long net_addr; net_port = htons(host_port); //转换为网络字节序 net_addr = htonl(host_addr); printf("Host ordered port: %#x \n", host_port); printf("Network ordered port: %#x \n", net_port); printf("Host ordered address: %#lx \n", host_addr); printf("Network ordered address: %#lx \n", net_addr); return 0;&#125; 编译运行： 12gcc endian_conv.c -o conv./conv 结果： 1234Host ordered port: 0x1234Network ordered port: 0x3412Host ordered address: 0x12345678Network ordered address: 0x78563412 这是在小端 CPU 的运行结果。大部分人会得到相同的结果，因为 Intel 和 AMD 的 CPU 都是小端序为标准。 3.4 网络地址的初始化与分配3.4.1 将字符串信息转换为网络字节序的整数型sockaddr_in 中需要的是 32 位整数型，但是我们只熟悉点分十进制表示法，那么改如何把类似于 201.211.214.36 转换为 4 字节的整数类型数据呢 ?幸运的是，有一个函数可以帮助我们完成它。 12#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *string); 具体示例： inet_addr.c 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char *argv[])&#123; char *addr1 = "1.2.3.4"; char *addr2 = "1.2.3.256"; unsigned long conv_addr = inet_addr(addr1); if (conv_addr == INADDR_NONE) printf("Error occured! \n"); else printf("Network ordered integer addr: %#lx \n", conv_addr); conv_addr = inet_addr(addr2); if (conv_addr == INADDR_NONE) printf("Error occured! \n"); else printf("Network ordered integer addr: %#lx \n", conv_addr); return 0;&#125; 编译运行： 12gcc inet_addr.c -o addr./addr 输出： 12Network ordered integer addr: 0x4030201Error occured! 1个字节能表示的最大整数是255，所以代码中 addr2 是错误的IP地址。从运行结果看，inet_addr 不仅可以转换地址，还可以检测有效性。 inet_aton 函数与 inet_addr 函数在功能上完全相同，也是将字符串形式的IP地址转换成整数型的IP地址。只不过该函数用了 in_addr 结构体，且使用频率更高。 1234567#include &lt;arpa/inet.h&gt;int inet_aton(const char *string, struct in_addr *addr);/*成功时返回 1 ，失败时返回 0string: 含有需要转换的IP地址信息的字符串地址值addr: 将保存转换结果的 in_addr 结构体变量的地址值*/ 函数调用示例： inet_aton.c 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;void error_handling(char *message);int main(int argc, char *argv[])&#123; char *addr = "127.232.124.79"; struct sockaddr_in addr_inet; if (!inet_aton(addr, &amp;addr_inet.sin_addr)) error_handling("Conversion error"); else printf("Network ordered integer addr: %#x \n", addr_inet.sin_addr.s_addr); return 0;&#125;void error_handling(char *message)&#123; fputs(message, stderr); fputc('\n', stderr); exit(1);&#125; 编译运行： 12gcc inet_aton.c -o aton./aton 运行结果： 1Network ordered integer addr: 0x4f7ce87f 可以看出，已经成功的把转换后的地址放进了 addr_inet.sin_addr.s_addr 中。 还有一个函数，与 inet_aton() 正好相反，它可以把网络字节序整数型IP地址转换成我们熟悉的字符串形式，函数原型如下： 12#include &lt;arpa/inet.h&gt;char *inet_ntoa(struct in_addr adr); 该函数将通过参数传入的整数型IP地址转换为字符串格式并返回。但要小心，返回值为 char 指针，返回字符串地址意味着字符串已经保存在内存空间，但是该函数未向程序员要求分配内存，而是再内部申请了内存保存了字符串。也就是说调用了该函数候要立即把信息复制到其他内存空间。因此，若再次调用 inet_ntoa 函数，则有可能覆盖之前保存的字符串信息。总之，再次调用 inet_ntoa 函数前返回的字符串地址是有效的。若需要长期保存，则应该将字符串复制到其他内存空间。 示例： inet_ntoa.c 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char *argv[])&#123; struct sockaddr_in addr1, addr2; char *str_ptr; char str_arr[20]; addr1.sin_addr.s_addr = htonl(0x1020304); addr2.sin_addr.s_addr = htonl(0x1010101); //把addr1中的结构体信息转换为字符串的IP地址形式 str_ptr = inet_ntoa(addr1.sin_addr); strcpy(str_arr, str_ptr); printf("Dotted-Decimal notation1: %s \n", str_ptr); inet_ntoa(addr2.sin_addr); printf("Dotted-Decimal notation2: %s \n", str_ptr); printf("Dotted-Decimal notation3: %s \n", str_arr); return 0;&#125; 编译运行： 12gcc inet_ntoa.c -o ntoa./ntoa 输出: 123Dotted-Decimal notation1: 1.2.3.4Dotted-Decimal notation2: 1.1.1.1Dotted-Decimal notation3: 1.2.3.4 3.4.2 网络地址初始化结合前面的内容，介绍套接字创建过程中，常见的网络信息初始化方法： 1234567struct sockaddr_in addr;char *serv_ip = "211.217,168.13"; //声明IP地址族char *serv_port = "9190"; //声明端口号字符串memset(&amp;addr, 0, sizeof(addr)); //结构体变量 addr 的所有成员初始化为0addr.sin_family = AF_INET; //制定地址族addr.sin_addr.s_addr = inet_addr(serv_ip); //基于字符串的IP地址初始化addr.sin_port = htons(atoi(serv_port)); //基于字符串的IP地址端口号初始化 3.5 基于 Windows 的实现略 3.6 习题 答案仅代表本人个人观点，不一定正确 IP地址族 IPV4 与 IPV6 有什么区别？在何种背景下诞生了 IPV6? 答：主要差别是IP地址所用的字节数，目前通用的是IPV4，目前IPV4的资源已耗尽，所以诞生了IPV6，它具有更大的地址空间。 通过 IPV4 网络 ID 、主机 ID 及路由器的关系说明公司局域网的计算机传输数据的过程 答：网络ID是为了区分网络而设置的一部分IP地址，假设向www.baidu.com公司传输数据，该公司内部构建了局域网。因为首先要向baidu.com传输数据，也就是说并非一开始就浏览所有四字节IP地址，首先找到网络地址，进而由baidu.com（构成网络的路由器）接收到数据后，传输到主机地址。比如向 203.211.712.103 传输数据，那就先找到 203.211.172 然后由这个网络的网关找主机号为 172 的机器传输数据。 套接字地址分为IP地址和端口号，为什么需要IP地址和端口号？或者说，通过IP地址可以区分哪些对象？通过端口号可以区分哪些对象？ 答：有了IP地址和端口号，才能把数据准确的传送到某个应用程序中。通过IP地址可以区分具体的主机，通过端口号可以区分主机上的应用程序。 请说明IP地址的分类方法，并据此说出下面这些IP的分类。 214.121.212.102（C类） 120.101.122.89（A类） 129.78.102.211（B类） 分类方法：A 类地址的首字节范围为：0127、B 类地址的首字节范围为：128191、C 类地址的首字节范围为：192~223 计算机通过路由器和交换机连接到互联网，请说出路由器和交换机的作用。 答：路由器和交换机完成外网和本网主机之间的数据交换。 什么是知名端口？其范围是多少？知名端口中具有代表性的 HTTP 和 FTP 的端口号各是多少？ 答：知名端口是要把该端口分配给特定的应用程序，范围是 0~1023 ，HTTP 的端口号是 80 ，FTP 的端口号是20和21 向套接字分配地址的 bind 函数原型如下： 1int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen); 而调用时则用： 1bind(serv_sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr) 此处 serv_addr 为 sockaddr_in 结构体变量。与函数原型不同，传入的是 sockaddr_in 结构体变量，请说明原因。 答：因为对于详细的地址信息使用 sockaddr 类型传递特别麻烦，进而有了 sockaddr_in 类型，其中基本与前面的类型保持一致，还有 sa_sata[4] 来保存地址信息，剩余全部填 0，所以强制转换后，不影响程序运行。 请解释大端序，小端序、网络字节序，并说明为何需要网络字节序。 答：CPU 向内存保存数据有两种方式，大端序是高位字节存放低位地址，小端序是高位字节存放高位地址，网络字节序是为了方便传输的信息统一性，统一成了大端序。 大端序计算机希望把 4 字节整数型 12 传递到小端序计算机。请说出数据传输过程中发生的字节序变换过程。 答：0x12-&gt;0x21 怎样表示回送地址？其含义是什么？如果向会送地址处传输数据将会发生什么情况？ 答：127.0.0.1 表示回送地址，指的是计算机自身的IP地址，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。 第 4 章 基于 TCP 的服务端/客户端（1）本章代码，在TCP-IP-NetworkNote中可以找到。 4.1 理解 TCP 和 UDP根据数据传输方式的不同，基于网络协议的套接字一般分为 TCP 套接字和 UDP 套接字。因为 TCP 套接字是面向连接的，因此又被称为基于流（stream）的套接字。 TCP 是 Transmission Control Protocol （传输控制协议）的简写，意为「对数据传输过程的控制」。因此，学习控制方法及范围有助于正确理解 TCP 套接字。 4.1.1 TCP/IP 协议栈 TCP/IP 协议栈共分为 4 层，可以理解为数据收发分成了 4 个层次化过程，通过层次化的方式来解决问题 4.1.2 链路层链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换，则需要物理连接，链路层就负责这些标准。 4.1.3 IP 层转备好物理连接候就要传输数据。为了再复杂网络中传输数据，首先要考虑路径的选择。向目标传输数据需要经过哪条路径？解决此问题的就是IP层，该层使用的协议就是IP。 IP 是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输过程中发生错误，则选择其他路径，但是如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。 4.1.4 TCP/UDP 层IP 层解决数据传输中的路径选择问题，秩序照此路径传输数据即可。TCP 和 UDP 层以 IP 层提供的路径信息为基础完成实际的数据传输，故该层又称为传输层。UDP 比 TCP 简单，现在我们只解释 TCP 。 TCP 可以保证数据的可靠传输，但是它发送数据时以 IP 层为基础（这也是协议栈层次化的原因） IP 层只关注一个数据包（数据传输基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由 IP 层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则可能导致后传输的数据包B比先传输的数据包A提早到达。另外，传输的数据包A、B、C中可能只收到A和C，甚至收到的C可能已经损毁 。反之，若添加 TCP 协议则按照如下对话方式进行数据交换。 主机A：正确接受第二个数据包 主机B：恩，知道了 主机A：正确收到第三个数据包 主机B：可我已经发送第四个数据包了啊！哦，您没收到吧，我给你重新发。 这就是 TCP 的作用。如果交换数据的过程中可以确认对方已经收到数据，并重传丢失的数据，那么即便IP层不保证数据传输，这类通信也是可靠的。 4.1.5 应用层上述内容是套接字通信过程中自动处理的。选择数据传输路径、数据确认过程都被隐藏到套接字内部。向程序员提供的工具就是套接字，只需要利用套接字编出程序即可。编写软件的过程中，需要根据程序的特点来决定服务器和客户端之间的数据传输规则，这便是应用层协议。 4.2 实现基于 TCP 的服务器/客户端4.2.1 TCP 服务端的默认函数的调用程序 调用 socket 函数创建套接字，声明并初始化地址信息的结构体变量，调用 bind 函数向套接字分配地址。 4.2.2 进入等待连接请求状态已经调用了 bind 函数给套接字分配地址，接下来就是要通过调用 listen 函数进入等待连接请求状态。只有调用了 listen 函数，客户端才能进入可发出连接请求的状态。换言之，这时客户端才能调用 connect 函数 12345#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);//成功时返回0，失败时返回-1//sock: 希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数称为服务端套接字//backlog: 连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列 4.2.3 受理客户端连接请求调用 listen 函数后，则应该按序受理。受理请求意味着可接受数据的状态。进入这种状态所需的部件是套接字，但是此时使用的不是服务端套接字，此时需要另一个套接字，但是没必要亲自创建，下面的函数将自动创建套接字。 12345678#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);/*成功时返回文件描述符，失败时返回-1sock: 服务端套接字的文件描述符addr: 保存发起连接请求的客户端地址信息的变量地址值addrlen: 的第二个参数addr结构体的长度，但是存放有长度的变量地址。*/ sccept 函数受理连接请求队列中待处理的客户端连接请求。函数调用成功后，accept 内部将产生用于数据 I/O 的套接字，并返回其文件描述符。需要强调的是套接字是自动创建的，并自动与发起连接请求的客户端建立连接。 4.2.4 回顾 Hello World 服务端 代码：hello_server.c 重新整理一下代码的思路 服务端实现过程中首先要创建套接字，此时的套接字并非是真正的服务端套接字 为了完成套接字地址的分配，初始化结构体变量并调用 bind 函数。 调用 listen 函数进入等待连接请求状态。连接请求状态队列的长度设置为5.此时的套接字才是服务端套接字。 调用 accept 函数从队头取 1 个连接请求与客户端建立连接，并返回创建的套接字文件描述符。另外，调用 accept 函数时若等待队列为空，则 accept 函数不会返回，直到队列中出现新的客户端连接。 调用 write 函数向客户端传送数据，调用 close 关闭连接 4.2.5 TCP 客户端的默认函数调用顺序 与服务端相比，区别就在于「请求连接」，他是创建客户端套接字后向服务端发起的连接请求。服务端调用 listen 函数后创建连接请求等待队列，之后客户端即可请求连接。 12345678#include &lt;sys/socket.h&gt;int connect(int sock, struct sockaddr *servaddr, socklen_t addrlen);/*成功时返回0，失败返回-1sock:客户端套接字文件描述符servaddr: 保存目标服务器端地址信息的变量地址值addrlen: 以字节为单位传递给第二个结构体参数 servaddr 的变量地址长度*/ 客户端调用 connect 函数候，发生以下函数之一才会返回（完成函数调用）: 服务端接受连接请求 发生断网等一场状况而中断连接请求 注意：接受连接不代表服务端调用 accept 函数，其实只是服务器端把连接请求信息记录到等待队列。因此 connect 函数返回后并不应该立即进行数据交换。 4.2.6 回顾 Hello World 客户端 代码：hello_client.c 重新理解这个程序： 创建准备连接服务器的套接字，此时创建的是 TCP 套接字 结构体变量 serv_addr 中初始化IP和端口信息。初始化值为目标服务器端套接字的IP和端口信息。 调用 connect 函数向服务端发起连接请求 完成连接后，接收服务端传输的数据 接收数据后调用 close 函数关闭套接字，结束与服务器端的连接。 4.2.7 基于 TCP 的服务端/客户端函数调用关系 关系如上图所示。 4.3 实现迭代服务端/客户端编写一个回声（echo）服务器/客户端。顾名思义，服务端将客户端传输的字符串数据原封不动的传回客户端，就像回声一样。在此之前，需要解释一下迭代服务器端。 4.3.1 实现迭代服务器端在 Hello World 的例子中，等待队列的作用没有太大意义。如果想继续处理好后面的客户端请求应该怎样扩展代码？最简单的方式就是插入循环反复调用 accept 函数，如图: 可以看出，调用 accept 函数后，紧接着调用 I/O 相关的 read write 函数，然后调用 close 函数。这并非针对服务器套接字，而是针对 accept 函数调用时创建的套接字。 4.3.2 迭代回声服务器端/客户端程序运行的基本方式： 服务器端在同一时刻只与一个客户端相连，并提供回声服务。 服务器端依次向 5 个客户端提供服务并退出。 客户端接受用户输入的字符串并发送到服务器端。 服务器端将接受的字符串数据传回客户端，即「回声」 服务器端与客户端之间的字符串回声一直执行到客户端输入 Q 为止。 以下是服务端与客户端的代码： echo_server.c echo_client.c 编译: 12gcc echo_client.c -o eclientgcc echo_server.c -o eserver 分别运行: 12./eserver 9190./eclient 127.0.0.1 9190 过程和结果： 在一个服务端开启后，用另一个终端窗口开启客户端，然后程序会让你输入字符串，然后客户端输入什么字符串，客户端就会返回什么字符串，按 q 退出。这时服务端的运行并没有结束，服务端一共要处理 5 个客户端的连接，所以另外开多个终端窗口同时开启客户端，服务器按照顺序进行处理。 server: client: 4.3.3 回声客户端存在的问题以上代码有一个假设「每次调用 read、write函数时都会以字符串为单位执行实际 I/O 操作」 但是「第二章」中说过「TCP 不存在数据边界」，上述客户端是基于 TCP 的，因此多次调用 write 函数传递的字符串有可能一次性传递到服务端。此时客户端有可能从服务端收到多个字符串，这不是我们想要的结果。还需要考虑服务器的如下情况： 「字符串太长，需要分 2 个包发送！」 服务端希望通过调用 1 次 write 函数传输数据，但是如果数据太大，操作系统就有可能把数据分成多个数据包发送到客户端。另外，在此过程中，客户端可能在尚未收到全部数据包时就调用 read 函数。 以上的问题都是源自 TCP 的传输特性，解决方法在第 5 章。 4.4 基于 Windows 的实现暂略 4.5 习题 答案仅代表本人个人观点，不一定是正确答案。 请你说明 TCP/IP 的 4 层协议栈，并说明 TCP 和 UDP 套接字经过的层级结构差异。 答：TCP/IP 的四层协议分为：应用层、TCP/UDP 层、IP层、链路层。差异是一个经过 TCP 层，一个经过 UDP 层。 请说出 TCP/IP 协议栈中链路层和IP层的作用，并给出二者关系 答：链路层是物理链接领域标准化的结果，专门定义网络标准。若两台主机通过网络进行数据交换，则首先要做到的就是进行物理链接。IP层：为了在复杂的网络中传输数据，首先需要考虑路径的选择。关系：链路层负责进行一系列物理连接，而IP层负责选择正确可行的物理路径。 为何需要把 TCP/IP 协议栈分成 4 层（或7层）？开放式回答。 答：ARPANET 的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次式的。分册的好处：①隔层之间是独立的②灵活性好③结构上可以分隔开④易于实现和维护⑤能促进标准化工作。 客户端调用 connect 函数向服务器端发送请求。服务器端调用哪个函数后，客户端可以调用 connect 函数？ 答：服务端调用 listen 函数后，客户端可以调用 connect 函数。因为，服务端调用 listen 函数后，服务端套接字才有能力接受请求连接的信号。 什么时候创建连接请求等待队列？它有何种作用？与 accept 有什么关系？ 答：服务端调用 listen 函数后，accept函数正在处理客户端请求时， 更多的客户端发来了请求连接的数据，此时，就需要创建连接请求等待队列。以便于在accept函数处理完手头的请求之后，按照正确的顺序处理后面正在排队的其他请求。与accept函数的关系：accept函数受理连接请求等待队列中待处理的客户端连接请求。 客户端中为何不需要调用 bind 函数分配地址？如果不调用 bind 函数，那何时、如何向套接字分配IP地址和端口号？ 答：在调用 connect 函数时分配了地址，客户端IP地址和端口在调用 connect 函数时自动分配，无需调用标记的 bind 函数进行分配。 第 5 章 基于 TCP 的服务端/客户端（2）本章代码，在TCP-IP-NetworkNote中可以找到。 上一章仅仅是从编程角度学习实现方法，并未详细讨论 TCP 的工作原理。因此，本章将想次讲解 TCP 中必要的理论知识，还将给出第 4 章客户端问题的解决方案。 5.1 回声客户端的完美实现5.1.1 回声服务器没有问题，只有回声客户端有问题？问题不在服务器端，而在客户端，只看代码可能不好理解，因为 I/O 中使用了相同的函数。先回顾一下服务器端的 I/O 相关代码： 12while ((str_len = read(clnt_sock, message, BUF_SIZE)) != 0) write(clnt_sock, message, str_len); 接着是客户端代码: 12write(sock, message, strlen(message));str_len = read(sock, message, BUF_SIZE - 1); 二者都在村换调用 read 和 write 函数。实际上之前的回声客户端将 100% 接受字节传输的数据，只不过接受数据时的单位有些问题。扩展客户端代码回顾范围，下面是，客户端的代码: 12345678910111213while (1)&#123; fputs("Input message(Q to quit): ", stdout); fgets(message, BUF_SIZE, stdin); if (!strcmp(message, "q\n") || !strcmp(message, "Q\n")) break; write(sock, message, strlen(message)); str_len = read(sock, message, BUF_SIZE - 1); message[str_len] = 0; printf("Message from server: %s", message);&#125; 现在应该理解了问题，回声客户端传输的是字符串，而且是通过调用 write 函数一次性发送的。之后还调用一次 read 函数，期待着接受自己传输的字符串，这就是问题所在。 5.1.2 回声客户端问题的解决办法这个问题其实很容易解决，因为可以提前接受数据的大小。若之前传输了20字节长的字符串，则再接收时循环调用 read 函数读取 20 个字节即可。既然有了解决办法，那么代码如下： echo_client2.c 这样修改为了接收所有传输数据而循环调用 read 函数。测试及运行结果可参考第四章。 5.1.3 如果问题不在于回声客户端：定义应用层协议回声客户端可以提前知道接收数据的长度，这在大多数情况下是不可能的。那么此时无法预知接收数据长度时应该如何手法数据？这是需要的是应用层协议的定义。在收发过程中定好规则（协议）以表示数据边界，或者提前告知需要发送的数据的大小。服务端/客户端实现过程中逐步定义的规则集合就是应用层协议。 现在写一个小程序来体验应用层协议的定义过程。要求： 服务器从客户端获得多个数组和运算符信息。 服务器接收到数字候对齐进行加减乘运算，然后把结果传回客户端。 例： 向服务器传递3,5,9的同时请求加法运算，服务器返回3+5+9的结果 请求做乘法运算，客户端会收到3*5*9的结果 如果向服务器传递4,3,2的同时要求做减法，则返回4-3-2的运算结果。 请自己实现一个程序来实现功能。 我自己的实现： My_op_server.c My_op_client.c 编译： 12gcc My_op_client.c -o myclientgcc My_op_server.c -o myserver 结果： 其实主要是对程序的一点点小改动，只需要再客户端固定好发送的格式，服务端按照固定格式解析，然后返回结果即可。 书上的实现： op_client.c op_server.c 阅读代码要注意一下，int*与char之间的转换。TCP 中不存在数据边界。 编译： 12gcc op_client.c -o opclientgcc op_server.c -o opserver 运行: 12./opserver 9190./opclient 127.0.0.1 9190 结果： 5.2 TCP 原理5.2.1 TCP 套接字中的 I/O 缓冲TCP 套接字的数据收发无边界。服务器即使调用 1 次 write 函数传输 40 字节的数据，客户端也有可能通过 4 次 read 函数调用每次读取 10 字节。但此处也有一些一问，服务器一次性传输了 40 字节，而客户端竟然可以缓慢的分批接受。客户端接受 10 字节后，剩下的 30 字节在何处等候呢？ 实际上，write 函数调用后并非立即传输数据， read 函数调用后也并非马上接收数据。如图所示，write 函数滴啊用瞬间，数据将移至输出缓冲；read 函数调用瞬间，从输入缓冲读取数据。 I/O 缓冲特性可以整理如下： I/O 缓冲在每个 TCP 套接字中单独存在 I/O 缓冲在创建套接字时自动生成 即使关闭套接字也会继续传递输出缓冲中遗留的数据 关闭套接字将丢失输入缓冲中的数据 假设发生以下情况，会发生什么事呢？ 客户端输入缓冲为 50 字节，而服务器端传输了 100 字节。 因为 TCP 不会发生超过输入缓冲大小的数据传输。也就是说，根本不会发生这类问题，因为 TCP 会控制数据流。TCP 中有滑动窗口（Sliding Window）协议，用对话方式如下： A：你好，最多可以向我传递 50 字节 B：好的 A：我腾出了 20 字节的空间，最多可以接受 70 字节 B：好的 数据收发也是如此，因此 TCP 中不会因为缓冲溢出而丢失数据。 write 函数在数据传输完成时返回。 5.2.2 TCP 内部工作原理 1：与对方套接字的连接TCP 套接字从创建到消失所经过的过程分为如下三步： 与对方套接字建立连接 与对方套接字进行数据交换 断开与对方套接字的连接 首先讲解与对方套接字建立连接的过程。连接过程中，套接字的对话如下： 套接字A：你好，套接字 B。我这里有数据给你，建立连接吧 套接字B：好的，我这边已就绪 套接字A：谢谢你受理我的请求 TCP 在实际通信中也会经过三次对话过程，因此，该过程又被称为 Three-way handshaking（三次握手）。接下来给出连接过程中实际交换的信息方式： 套接字是全双工方式工作的。也就是说，它可以双向传递数据。因此，收发数据前要做一些准备。首先请求连接的主机 A 要给主机 B 传递以下信息： [SYN] SEQ : 1000 , ACK:- 该消息中的 SEQ 为 1000 ，ACK 为空，而 SEQ 为1000 的含义如下： 现在传递的数据包的序号为 1000，如果接收无误，请通知我向您传递 1001 号数据包。 这是首次请求连接时使用的消息，又称为 SYN。SYN 是 Synchronization 的简写，表示收发数据前传输的同步消息。接下来主机 B 向 A 传递以下信息： [SYN+ACK] SEQ: 2000, ACK: 1001 此时 SEQ 为 2000，ACK 为 1001，而 SEQ 为 2000 的含义如下： 现传递的数据包号为 2000 ，如果接受无误，请通知我向您传递 2001 号数据包。 而 ACK 1001 的含义如下： 刚才传输的 SEQ 为 1000 的数据包接受无误，现在请传递 SEQ 为 1001 的数据包。 对于主机 A 首次传输的数据包的确认消息（ACK 1001）和为主机 B 传输数据做准备的同步消息（SEQ 2000）捆绑发送。因此，此种类消息又称为 SYN+ACK。 收发数据前向数据包分配序号，并向对方通报此序号，这都是为了防止数据丢失做的准备。通过项数据包分配序号并确认，可以在数据包丢失时马上查看并重传丢失的数据包。因此 TCP 可以保证可靠的数据传输。 通过这三个过程，这样主机 A 和主机 B 就确认了彼此已经准备就绪。 5.2.3 TCP 内部工作原理 2：与对方主机的数据交换通过第一步三次握手过程完成了数据交换准备，下面就开始正式收发数据，其默认方式如图所示： 图上给出了主机 A 分成 2 个数据包向主机 B 传输 200 字节的过程。首先，主机 A 通过 1 个数据包发送 100 个字节的数据，数据包的 SEQ 为 1200 。主机 B 为了确认这一点，向主机 A 发送 ACK 1301 消息。 此时的 ACK 号为 1301 而不是 1201，原因在于 ACK 号的增量为传输的数据字节数。假设每次 ACK 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确 100 个字节全都正确传递还是丢失了一部分，比如只传递了 80 字节。因此按照如下公式传递 ACK 信息： ACK 号 = SEQ 号 + 传递的字节数 + 1 与三次握手协议相同，最后 + 1 是为了告知对方下次要传递的 SEQ 号。下面分析传输过程中数据包丢失的情况： ‘ 上图表示了通过 SEQ 1301 数据包向主机 B 传递 100 字节数据。但中间发生了错误，主机 B 未收到，经过一段时间后，主机 A 仍然未收到对于 SEQ 1301 的 ACK 的确认，因此试着重传该数据包。为了完成该数据包的重传，TCP 套接字启动计时器以等待 ACK 应答。若相应计时器发生超时（Time-out!）则重传。 5.2.4 TCP 内部工作原理 3：断开套接字的连接TCP 套接字的结束过程也非常优雅。如果对方还有数据需要传输时直接断掉该连接会出问题，所以断开连接时需要双方协商，断开连接时双方的对话如下： 套接字A：我希望断开连接 套接字B：哦，是吗？请稍后。 套接字A：我也准备就绪，可以断开连接。 套接字B：好的，谢谢合作。 先由套接字 A 向套接字 B 传递断开连接的信息，套接字 B 发出确认收到的消息，然后向套接字 A 传递可以断开连接的消息，套接字 A 同样发出确认消息。 图中数据包内的 FIN 表示断开连接。也就是说，双方各发送 1 次 FIN 消息后断开连接。此过过程经历 4 个阶段，因此又称四次握手（Four-way handshaking）。SEQ 和 ACK 的含义与之前讲解的内容一致，省略。图中，主机 A 传递了两次 ACK 5001，也许这里会有困惑。其实，第二次 FIN 数据包中的 ACK 5001 只是因为接收了 ACK 消息后未接收到的数据重传的。 5.3 基于 Windows 的实现暂略 5.4 习题 答案仅代表本人个人观点，可能不是正确答案。 请说明 TCP 套接字连接设置的三次握手过程。尤其是 3 次数据交换过程每次收发的数据内容。 答：三次握手主要分为：①与对方套接字建立连接②与对方套接字进行数据交换③断开与对方套接字的连接。每次收发的数据内容主要有：①由主机1给主机2发送初始的SEQ，首次连接请求是关键字是SYN，表示收发数据前同步传输的消息。②主机2收到报文以后，给主机 1 传递信息，用一个新的SEQ表示自己的序号，然后ACK代表已经接受到主机1的消息，希望接受下一个消息③主机1收到主机2的确认以后，还需要给主机2给出确认，此时再发送一次SEQ和ACK。 TCP 是可靠的数据传输协议，但在通过网络通信的过程中可能丢失数据。请通过 ACK 和 SEQ 说明 TCP 通过和何种机制保证丢失数据的可靠传输。 答：通过超时重传机制来保证，如果报文发出去的特定时间内，发送消息的主机没有收到另一个主机的回复，那么就继续发送这条消息，直到收到回复为止。 TCP 套接字中调用 write 和 read 函数时数据如何移动？结合 I/O 缓冲进行说明。 答：TCP 套接字调用 write 函数时，数据将移至输出缓冲，在适当的时候，传到对方输入缓冲。这时对方将调用 read 函数从输入缓冲中读取数据。 对方主机的输入缓冲剩余 50 字节空间时，若本主机通过 write 函数请求传输 70 字节，请问 TCP 如何处理这种情况？ 答：TCP 中有滑动窗口控制协议，所以传输的时候会保证传输的字节数小于等于自己能接受的字节数。 第 6 章 基于 UDP 的服务端/客户端本章代码，在TCP-IP-NetworkNote中可以找到。 TCP 是内容较多的一个协议，而本章中的 UDP 内容较少，但是也很重要。 6.1 理解 UDP6.1.1 UDP 套接字的特点通过寄信来说明 UDP 的工作原理，这是讲解 UDP 时使用的传统示例，它与 UDP 的特点完全相同。寄信前应现在信封上填好寄信人和收信人的地址，之后贴上邮票放进邮筒即可。当然，信件的特点使我们无法确认信件是否被收到。邮寄过程中也可能发生信件丢失的情况。也就是说，信件是一种不可靠的传输方式，UDP 也是一种不可靠的数据传输方式。 因为 UDP 没有 TCP 那么复杂，所以编程难度比较小，性能也比 TCP 高。在更重视性能的情况下可以选择 UDP 的传输方式。 TCP 与 UDP 的区别很大一部分来源于流控制。也就是说 TCP 的生命在于流控制。 6.1.2 UDP 的工作原理如图所示： 从图中可以看出，IP 的作用就是让离开主机 B 的 UDP 数据包准确传递到主机 A 。但是把 UDP 数据包最终交给主机 A 的某一 UDP 套接字的过程是由 UDP 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。 6.1.3 UDP 的高效使用UDP 也具有一定的可靠性。对于通过网络实时传递的视频或者音频时情况有所不同。对于多媒体数据而言，丢失一部分数据也没有太大问题，这只是会暂时引起画面抖动，或者出现细微的杂音。但是要提供实时服务，速度就成为了一个很重要的因素。因此流控制就显得有一点多余，这时就要考虑使用 UDP 。TCP 比 UDP 慢的原因主要有以下两点： 收发数据前后进行的连接设置及清楚过程。 收发过程中为保证可靠性而添加的流控制。 如果收发的数据量小但是需要频繁连接时，UDP 比 TCP 更高效。 6.2 实现基于 UDP 的服务端/客户端6.2.1 UDP 中的服务端和客户端没有连接UDP 中的服务端和客户端不像 TCP 那样在连接状态下交换数据，因此与 TCP 不同，无需经过连接过程。也就是说，不必调用 TCP 连接过程中调用的 listen 和 accept 函数。UDP 中只有创建套接字和数据交换的过程。 6.2.2 UDP 服务器和客户端均只需一个套接字TCP 中，套接字之间应该是一对一的关系。若要向 10 个客户端提供服务，除了守门的服务器套接字之外，还需要 10 个服务器套接字。但在 UDP 中，不管事服务器端还是客户端都只需要 1 个套接字。只需要一个 UDP 套接字就可以向任意主机传输数据，如图所示： 图中展示了 1 个 UDP 套接字与 2 个不同主机交换数据的过程。也就是说，只需 1 个 UDP 套接字就能和多台主机进行通信。 6.2.3 基于 UDP 的数据 I/O 函数创建好 TCP 套接字以后，传输数据时无需加上地址信息。因为 TCP 套接字将保持与对方套接字的连接。换言之，TCP 套接字知道目标地址信息。但 UDP 套接字不会保持连接状态（UDP 套接字只有简单的邮筒功能），因此每次传输数据时都需要添加目标的地址信息。这相当于寄信前在信件中填写地址。接下来是 UDP 的相关函数： 123456789101112#include &lt;sys/socket.h&gt;ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen);/*成功时返回传输的字节数，失败是返回 -1sock: 用于传输数据的 UDP 套接字buff: 保存待传输数据的缓冲地址值nbytes: 待传输的数据长度，以字节为单位flags: 可选项参数，若没有则传递 0to: 存有目标地址的 sockaddr 结构体变量的地址值addrlen: 传递给参数 to 的地址值结构体变量长度*/ 上述函数与之前的 TCP 输出函数最大的区别在于，此函数需要向它传递目标地址信息。接下来介绍接收 UDP 数据的函数。UDP 数据的发送并不固定，因此该函数定义为可接受发送端信息的形式，也就是将同时返回 UDP 数据包中的发送端信息。 123456789101112#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);/*成功时返回传输的字节数，失败是返回 -1sock: 用于传输数据的 UDP 套接字buff: 保存待传输数据的缓冲地址值nbytes: 待传输的数据长度，以字节为单位flags: 可选项参数，若没有则传递 0from: 存有发送端地址信息的 sockaddr 结构体变量的地址值addrlen: 保存参数 from 的结构体变量长度的变量地址值。*/ 编写 UDP 程序的最核心的部分就在于上述两个函数，这也说明二者在 UDP 数据传输中的地位。 6.2.4 基于 UDP 的回声服务器端/客户端下面是实现的基于 UDP 的回声服务器的服务器端和客户端： 代码： uecho_client.c uecho_server.c 编译运行： 1234gcc uecho_client.c -o uclientgcc uecho_server.c -o userver./server 9190./uclient 127.0.0.1 9190 结果： TCP 客户端套接字在调用 connect 函数时自动分配IP地址和端口号，既然如此，UDP 客户端何时分配IP地址和端口号？ 6.2.5 UDP 客户端套接字的地址分配仔细观察 UDP 客户端可以发现，UDP 客户端缺少了把IP和端口分配给套接字的过程。TCP 客户端调用 connect 函数自动完成此过程，而 UDP 中连接能承担相同功能的函数调用语句都没有。究竟在什么时候分配IP和端口号呢？ UDP 程序中，调用 sendto 函数传输数据前应该完成对套接字的地址分配工作，因此调用 bind 函数。当然，bind 函数在 TCP 程序中出现过，但 bind 函数不区分 TCP 和 UDP，也就是说，在 UDP 程序中同样可以调用。另外，如果调用 sendto 函数尚未分配地址信息，则在首次调用 sendto 函数时给相应套接字自动分配 IP 和端口。而且此时分配的地址一直保留到程序结束为止，因此也可以用来和其他 UDP 套接字进行数据交换。当然，IP 用主机IP，端口号用未选用的任意端口号。 综上所述，调用 sendto 函数时自动分配IP和端口号，因此，UDP 客户端中通常无需额外的地址分配过程。所以之前的示例中省略了该过程。这也是普遍的实现方式。 6.3 UDP 的数据传输特性和调用 connect 函数6.3.1 存在数据边界的 UDP 套接字前面说得 TCP 数据传输中不存在数据边界，这表示「数据传输过程中调用 I/O 函数的次数不具有任何意义」 相反，UDP 是具有数据边界的下一，传输中调用 I/O 函数的次数非常重要。因此，输入函数的调用次数和输出函数的调用次数完全一致，这样才能保证接收全部已经发送的数据。例如，调用 3 次输出函数发送的数据必须通过调用 3 次输入函数才能接收完。通过一个例子来进行验证： bound_host1.c bound_host2.c 编译运行： 1234gcc bound_host1.c -o host1gcc bound_host2.c -o host2./host1 9190./host2 127.0.0.1 9190 运行结果： host1 是服务端，host2 是客户端，host2 一次性把数据发给服务端后，结束程序。但是因为服务端每隔五秒才接收一次，所以服务端每隔五秒接收一次消息。 从运行结果也可以证明 UDP 通信过程中 I/O 的调用次数必须保持一致 6.3.2 已连接（connect）UDP 套接字与未连接（unconnected）UDP 套接字TCP 套接字中需注册待传传输数据的目标IP和端口号，而在 UDP 中无需注册。因此通过 sendto 函数传输数据的过程大概可以分为以下 3 个阶段： 第 1 阶段：向 UDP 套接字注册目标 IP 和端口号 第 2 阶段：传输数据 第 3 阶段：删除 UDP 套接字中注册的目标地址信息。 每次调用 sendto 函数时重复上述过程。每次都变更目标地址，因此可以重复利用同一 UDP 套接字向不同目标传递数据。这种未注册目标地址信息的套接字称为未连接套接字，反之，注册了目标地址的套接字称为连接 connected 套接字。显然，UDP 套接字默认属于未连接套接字。当一台主机向另一台主机传输很多信息时，上述的三个阶段中，第一个阶段和第三个阶段占整个通信过程中近三分之一的时间，缩短这部分的时间将会大大提高整体性能。 6.3.3 创建已连接 UDP 套接字创建已连接 UDP 套接字过程格外简单，只需针对 UDP 套接字调用 connect 函数。 123456sock = socket(PF_INET, SOCK_DGRAM, 0);memset(&amp;adr, 0, sizeof(adr));adr.sin_family = AF_INET;adr.sin_addr.s_addr = inet_addr(argv[1]);adr.sin_port = htons(atoi(argv[2]));connect(sock, (struct sockaddr *)&amp;adr, sizeof(adr)); 上述代码看似与 TCP 套接字创建过程一致，但 socket 函数的第二个参数分明是 SOCK_DGRAM 。也就是说，创建的的确是 UDP 套接字。当然针对 UDP 调用 connect 函数并不是意味着要与对方 UDP 套接字连接，这只是向 UDP 套接字注册目标IP和端口信息。 之后就与 TCP 套接字一致，每次调用 sendto 函数时只需传递信息数据。因为已经指定了收发对象，所以不仅可以使用 sendto、recvfrom 函数，还可以使用 write、read 函数进行通信。 下面的例子把之前的 uecho_client.c 程序改成了基于已连接 UDP 的套接字的程序，因此可以结合 uecho_server.c 程序运行。代码如下： uecho_con_client.c 编译运行过程与上面一样，故省略。 上面的代码中用 write、read 函数代替了 sendto、recvfrom 函数。 6.4 基于 Windows 的实现暂略 6.5 习题 以下答案仅代表本人个人观点，可能不是正确答案。 UDP 为什么比 TCP 快？为什么 TCP 传输可靠而 TCP 传输不可靠？ 答：为了提供可靠的数据传输服务，TCP 在不可靠的IP层进行流控制，而 UDP 缺少这种流控制。所以 UDP 是不可靠的连接。 下面不属于 UDP 特点的是？ 下面加粗的代表此句话正确 UDP 不同于 TCP ，不存在连接概念，所以不像 TCP 那样只能进行一对一的数据传输。 利用 UDP 传输数据时，如果有 2 个目标，则需要 2 个套接字。 UDP 套接字中无法使用已分配给 TCP 的同一端口号 UDP 套接字和 TCP 套接字可以共存。若需要，可以同时在同一主机进行 TCP 和 UDP 数据传输。 针对 UDP 函数也可以调用 connect 函数，此时 UDP 套接字跟 TCP 套接字相同，也需要经过 3 次握手阶段。 UDP 数据报向对方主机的 UDP 套接字传递过程中，IP 和 UDP 分别负责哪些部分？ 答：IP的作用就是让离开主机的 UDP 数据包准确传递到另一个主机。但把 UDP 包最终交给主机的某一 UDP 套接字的过程则是由 UDP 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。 UDP 一般比 TCP 快，但根据交换数据的特点，其差异可大可小。请你说明何种情况下 UDP 的性能优于 TCP？ 答：如果收发数据量小但需要频繁连接时，UDP 比 TCP 更高效。 客户端 TCP 套接字调用 connect 函数时自动分配IP和端口号。UDP 中不调用 bind 函数，那何时分配IP和端口号？ 答：在首次调用 sendto 函数时自动给相应的套接字分配IP和端口号。而且此时分配的地址一直保留到程序结束为止。 TCP 客户端必须调用 connect 函数，而 UDP 可以选择性调用。请问，在 UDP 中调用 connect 函数有哪些好处？ 答：要与同一个主机进行长时间通信时，将 UDP 套接字变成已连接套接字会提高效率。因为三个阶段中，第一个阶段和第三个阶段占用了一大部分时间，调用 connect 函数可以节省这些时间。 第 7 章 优雅的断开套接字的连接本章代码，在TCP-IP-NetworkNote中可以找到。 本章讨论如何优雅的断开套接字的连接，之前用的方法不够优雅是因为，我们是调用 close 函数或 closesocket 函数单方面断开连接的。 7.1 基于 TCP 的半关闭TCP 的断开连接过程比建立连接更重要，因为连接过程中一般不会出现大问题，但是断开过程可能发生预想不到的情况。因此应该准确掌控。所以要掌握半关闭（Half-close），才能明确断开过程。 7.1.1 单方面断开连接带来的问题Linux 和 Windows 的 closesocket 函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。因此在某些情况下，通信一方单方面的断开套接字连接，显得不太优雅。如图所示： 图中描述的是 2 台主机正在进行双向通信，主机 A 发送完最后的数据后，调用 close 函数断开了最后的连接，之后主机 A 无法再接受主机 B 传输的数据。实际上，是完全无法调用与接受数据相关的函数。最终，由主机 B 传输的、主机 A 必须要接受的数据也销毁了。 为了解决这类问题，「只关闭一部分数据交换中使用的流」的方法应运而生。断开一部分连接是指，可以传输数据但是无法接收，或可以接受数据但无法传输。顾名思义就是只关闭流的一半。 7.1.2 套接字和流（Stream）两台主机通过套接字建立连接后进入可交换数据的状态，又称「流形成的状态」。也就是把建立套接字后可交换数据的状态看作一种流。 此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也止呕能向一个方向流动。因此，为了进行双向通信，需要如图所示的两个流： 一旦两台主机之间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。当然，其中一个主机的输入流与另一个主机的输出流相连，而输出流则与另一个主机的输入流相连。另外，本章讨论的「优雅的断开连接方式」只断开其中 1 个流，而非同时断开两个流。Linux 和 Windows 的 closesocket 函数将同时断开这两个流，因此与「优雅」二字还有一段距离。 7.1.3 针对优雅断开的 shutdown 函数shutdown 用来关闭其中一个流： 1234567#include &lt;sys/socket.h&gt;int shutdown(int sock, int howto);/*成功时返回 0 ，失败时返回 -1sock: 需要断开套接字文件描述符howto: 传递断开方式信息*/ 调用上述函数时，第二个参数决定断开连接的方式，其值如下所示： SHUT_RD : 断开输入流 SHUT_WR : 断开输出流 SHUT_RDWR : 同时断开 I/O 流 若向 shutdown 的第二个参数传递SHUT_RD，则断开输入流，套接字无法接收数据。即使输入缓冲收到数据也回抹去，而且无法调用相关函数。如果向 shutdown 的第二个参数传递SHUT_WR，则中断输出流，也就无法传输数据。若如果输出缓冲中还有未传输的数据，则将传递给目标主机。最后，若传递关键字SHUT_RDWR，则同时中断 I/O 流。这相当于分 2 次调用 shutdown ，其中一次以SHUT_RD为参数，另一次以SHUT_WR为参数。 7.1.4 为何要半关闭考虑以下情况： 一旦客户端连接到服务器，服务器将约定的文件传输给客户端，客户端收到后发送字符串「Thank you」给服务器端。 此处「Thank you」的传递是多余的，这只是用来模拟客户端断开连接前还有数据要传输的情况。此时程序的还嫌难度并不小，因为传输文件的服务器端只需连续传输文件数据即可，而客户端无法知道需要接收数据到何时。客户端也没办法无休止的调用输入函数，因为这有可能导致程序阻塞。 是否可以让服务器和客户端约定一个代表文件尾的字符？ 这种方式也有问题，因为这意味这文件中不能有与约定字符相同的内容。为了解决该问题，服务端应最后向客户端传递 EOF 表示文件传输结束。客户端通过函数返回值接受 EOF ，这样可以避免与文件内容冲突。那么问题来了，服务端如何传递 EOF ？ 断开输出流时向主机传输 EOF。 当然，调用 close 函数的同时关闭 I/O 流，这样也会向对方发送 EOF 。但此时无法再接受对方传输的数据。换言之，若调用 close 函数关闭流，就无法接受客户端最后发送的字符串「Thank you」。这时需要调用 shutdown 函数，只关闭服务器的输出流。这样既可以发送 EOF ，同时又保留了输入流。下面实现收发文件的服务器端/客户端。 7.1.5 基于半关闭的文件传输程序上述文件传输服务器端和客户端的数据流可以整理如图： 下面的代码为编程简便，省略了大量错误处理代码。 file_client.c file_server.c 编译运行： 1234gcc file_client.c -o fclientgcc file_server.c -o fserver./fserver 9190./fclient 127.0.0.1 9190 结果： 客户端接受完成后，服务器会接收到来自客户端的感谢信息。 7.2 基于 Windows 的实现暂略 7.3 习题 以下答案仅代表本人个人观点，可能不是正确答案 解释 TCP 中「流」的概念。UDP 中能否形成流？请说明原因。 答：两台主机中通过套接字建立连接后进入可交换数据的状态，又称「流形成的状态」。也就是把建立套接字后可交换数据的状态看做一种流。UDP 没有建立连接的过程，所以不能形成流。 Linux 中的 close 函数或 Windows 中的 closesocket 函数属于单方面断开连接的方法，有可能带来一些问题。什么是单方面断开连接？什么情形下会出现问题？ 答：单方面断开连接就是两台主机正在通信，其中一台主机关闭了所有连接，那么一台主机向另一台主机传输的数据可能会没有接收到而损毁。传输文件的服务器只需连续传输文件数据即可，而客户端不知道需要接收数据到何时。客户端也没有办法无休止的调用输入函数。现在需要一个 EOF 代表数据已经传输完毕，那么这时就需要半关闭，服务端把自己的输出流关了，这时客户端就知数据已经传输完毕，因为服务端的输入流还没关，客户端可以给服务器汇报，接收完毕。 什么是半关闭？针对输出流执行半关闭的主机处于何种状态？半关闭会导致对方主机接收什么消息？ 答：半关闭就是把输入流或者输出流关了。针对输出流执行半关闭的主机处于可以接收数据而不能发送数据。半关闭会导致对方主机接收一个 EOF 文件结束符。对方就知道你的数据已经传输完毕。 第 8 章 域名及网络地址本章代码，在TCP-IP-NetworkNote中可以找到。 8.1 域名系统DNS 是对IP地址和域名进行相互转换的系统，其核心是 DNS 服务器 8.1.1 什么是域名域名就是我们常常在地址栏里面输入的地址，将比较难记忆的IP地址变成人类容易理解的信息。 8.1.2 DNS 服务器相当于一个字典，可以查询出某一个域名对应的IP地址 如图所示，显示了 DNS 服务器的查询路径。 8.2 IP地址和域名之间的转换8.2.1 程序中有必要使用域名吗？一句话，需要，因为IP地址可能经常改变，而且也不容易记忆，通过域名可以随时更改解析，达到更换IP的目的 8.2.2 利用域名获取IP地址使用以下函数可以通过传递字符串格式的域名获取IP地址 12345#include &lt;netdb.h&gt;struct hostent *gethostbyname(const char *hostname);/*成功时返回 hostent 结构体地址，失败时返回 NULL 指针*/ 这个函数使用方便，只要传递字符串，就可以返回域名对应的IP地址。只是返回时，地址信息装入 hostent 结构体。此结构体的定义如下： 12345678struct hostent&#123; char *h_name; /* Official name of host. */ char **h_aliases; /* Alias list. */ int h_addrtype; /* Host address type. */ int h_length; /* Length of address. */ char **h_addr_list; /* List of addresses from name server. */&#125;; 从上述结构体可以看出，不止返回IP信息，同时还带着其他信息一起返回。域名转换成IP时只需要关注 h_addr_list 。下面简要说明上述结构体的成员： h_name：该变量中存有官方域名（Official domain name）。官方域名代表某一主页，但实际上，一些著名公司的域名并没有用官方域名注册。 h_aliases：可以通过多个域名访问同一主页。同一IP可以绑定多个域名，因此，除官方域名外还可以指定其他域名。这些信息可以通过 h_aliases 获得。 h_addrtype：gethostbyname 函数不仅支持 IPV4 还支持 IPV6 。因此可以通过此变量获取保存在 h_addr_list 的IP地址族信息。若是 IPV4 ，则此变量中存有 AF_INET。 h_length：保存IP地址长度。若是 IPV4 地址，因为是 4 个字节，则保存4；IPV6 时，因为是 16 个字节，故保存 16 h_addr_list：这个是最重要的的成员。通过此变量以整数形式保存域名相对应的IP地址。另外，用户比较多的网站有可能分配多个IP地址给同一个域名，利用多个服务器做负载均衡，。此时可以通过此变量获取IP地址信息。 调用 gethostbyname 函数后，返回的结构体变量如图所示： 下面的代码通过一个例子来演示 gethostbyname 的应用，并说明 hostent 结构体变量特性。 gethostbyname.c 编译运行： 12gcc gethostbyname.c -o hostname./hostname www.baidu.com 结果： 如图所示，显示出了对百度的域名解析 可以看出，百度有一个域名解析是 CNAME 解析的，指向了shifen.com，关于百度具体的解析过程。 这一部分牵扯到了很多关于DNS解析的过程，还有 Linux 下关于域名解析的一些命令，我找了一部分资料，可以点下面的链接查看比较详细的： 关于百度DNS的解析过程 DNS解析的过程是什么，求详细的？ Linux DNS 查询剖析 Linux DNS查询命令 Linux中DNS服务器地址查询命令nslookup使用教程 DNS 原理入门 仔细阅读这一段代码： 1inet_ntoa(*(struct in_addr *)host-&gt;h_addr_list[i]) 若只看 hostent 的定义，结构体成员 h_addr_list 指向字符串指针数组（由多个字符串地址构成的数组）。但是字符串指针数组保存的元素实际指向的是 in_addr 结构体变量中地址值而非字符串，也就是说(struct in_addr *)host-&gt;h_addr_list[i]其实是一个指针，然后用*符号取具体的值。如图所示： 8.2.3 利用IP地址获取域名请看下面的函数定义： 12345678#include &lt;netdb.h&gt;struct hostent *gethostbyaddr(const char *addr, socklen_t len, int family);/*成功时返回 hostent 结构体变量地址值，失败时返回 NULL 指针addr: 含有IP地址信息的 in_addr 结构体指针。为了同时传递 IPV4 地址之外的全部信息，该变量的类型声明为 char 指针len: 向第一个参数传递的地址信息的字节数，IPV4时为 4 ，IPV6 时为16.family: 传递地址族信息，ipv4 是 AF_INET ，IPV6是 AF_INET6*/ 下面的代码演示使用方法： gethostbyaddr.c 编译运行： 12gcc gethostbyaddr.c -o hostaddr./hostaddr 8.8.8.8 结果： 从图上可以看出，8.8.8.8这个IP地址是谷歌的。 8.3 基于 Windows 的实现暂略 8.4 习题 以下答案仅代表本人个人观点，可能不是正确答案。 下列关于DNS的说法错误的是？ 答：字体加粗的表示正确答案。 因为DNS从存在，故可以使用域名代替IP DNS服务器实际上是路由器，因为路由器根据域名决定数据的路径 所有域名信息并非集中与 1 台 DNS 服务器，但可以获取某一 DNS 服务器中未注册的所有地址 DNS 服务器根据操作系统进行区分，Windows 下的 DNS 服务器和 Linux 下的 DNS 服务器是不同的。 阅读如下对话，并说明东秀的方案是否可行。（因为对话的字太多，用图代替） 答：答案就是可行，DNS 服务器是分布式的，一台坏了可以找其他的。 再浏览器地址输入 www.orentec.co.kr ，并整理出主页显示过程。假设浏览器访问默认 DNS 服务器中并没有关于 www.orentec.co.kr 的地址信息. 答：可以参考一下知乎回答，在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？,我用我自己的理解，简单说一下，首先会去向上一级的 DNS 服务器去查询，通过这种方式逐级向上传递信息，一直到达根服务器时，它知道应该向哪个 DNS 服务器发起询问。向下传递解析请求，得到IP地址候原路返回，最后会将解析的IP地址传递到发起请求的主机。 第 9 章 套接字的多种可选项本章代码，在TCP-IP-NetworkNote中可以找到。 9.1 套接字可选项和 I/O 缓冲大小我们进行套接字编程时往往只关注数据通信，而忽略了套接字具有的不同特性。但是，理解这些特性并根据实际需要进行更改也很重要 9.1.1 套接字多种可选项我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。 协议层 选项名 读取 设置 SOL_SOCKET SO_SNDBUF O O SOL_SOCKET SO_RCVBUF O O SOL_SOCKET SO_REUSEADDR O O SOL_SOCKET SO_KEEPALIVE O O SOL_SOCKET SO_BROADCAST O O SOL_SOCKET SO_DONTROUTE O O SOL_SOCKET SO_OOBINLINE O O SOL_SOCKET SO_ERROR O X SOL_SOCKET SO_TYPE O X IPPROTO_IP IP_TOS O O IPPROTO_IP IP_TTL O O IPPROTO_IP IP_MULTICAST_TTL O O IPPROTO_IP IP_MULTICAST_LOOP O O IPPROTO_IP IP_MULTICAST_IF O O IPPROTO_TCP TCP_KEEPALIVE O O IPPROTO_TCP TCP_NODELAY O O IPPROTO_TCP TCP_MAXSEG O O 从表中可以看出，套接字可选项是分层的。 IPPROTO_IP 可选项是IP协议相关事项 IPPROTO_TCP 层可选项是 TCP 协议的相关事项 SOL_SOCKET 层是套接字的通用可选项。 9.1.2 getsockopt &amp; setsockopt可选项的读取和设置通过以下两个函数来完成 1234567891011#include &lt;sys/socket.h&gt;int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen);/*成功时返回 0 ，失败时返回 -1sock: 用于查看选项套接字文件描述符level: 要查看的可选项协议层optname: 要查看的可选项名optval: 保存查看结果的缓冲地址值optlen: 向第四个参数传递的缓冲大小。调用函数候，该变量中保存通过第四个参数返回的可选项信息的字节数。*/ 上述函数可以用来读取套接字可选项，下面的函数可以更改可选项：d 1234567891011#include &lt;sys/socket.h&gt;int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen);/*成功时返回 0 ，失败时返回 -1sock: 用于更改选项套接字文件描述符level: 要更改的可选项协议层optname: 要更改的可选项名optval: 保存更改结果的缓冲地址值optlen: 向第四个参数传递的缓冲大小。调用函数候，该变量中保存通过第四个参数返回的可选项信息的字节数。*/ 下面的代码可以看出 getsockopt 的使用方法。下面示例用协议层为 SOL_SOCKET 、名为 SO_TYPE 的可选项查看套接字类型（TCP 和 UDP ）。 sock_type.c 编译运行： 12gcc sock_type.c -o sock_type./sock_type 结果： 1234SOCK_STREAM: 1SOCK_DGRAM: 2Socket type one: 1Socket type two: 2 首先创建了一个 TCP 套接字和一个 UDP 套接字。然后通过调用 getsockopt 函数来获得当前套接字的状态。 验证套接类型的 SO_TYPE 是只读可选项，因为套接字类型只能在创建时决定，以后不能再更改。 9.1.3 SO_SNDBUF &amp; SO_RCVBUF创建套接字的同时会生成 I/O 缓冲。关于 I/O 缓冲，可以去看第五章。 SO_RCVBUF 是输入缓冲大小相关可选项，SO_SNDBUF 是输出缓冲大小相关可选项。用这 2 个可选项既可以读取当前 I/O 大小，也可以进行更改。通过下列示例读取创建套接字时默认的 I/O 缓冲大小。 get_buf.c 编译运行： 12gcc get_buf.c -o getbuf./getbuf 运行结果： 12Input buffer size: 87380Output buffer size: 16384 可以看出本机的输入缓冲和输出缓冲大小。 下面的代码演示了，通过程序设置 I/O 缓冲区的大小 set_buf.c 编译运行： 12gcc get_buf.c -o setbuf./setbuf 结果: 12Input buffer size: 6144Output buffer size: 6144 输出结果和我们预想的不是很相同，缓冲大小的设置需谨慎处理，因此不会完全按照我们的要求进行。 9.2 SO_REUSEADDR9.2.1 发生地址分配错误（Binding Error）在学习 SO_REUSEADDR 可选项之前，应该好好理解 Time-wait 状态。看以下代码的示例： reuseadr_eserver.c 这是一个回声服务器的服务端代码，可以配合第四章的 echo_client.c 使用，在这个代码中，客户端通知服务器终止程序。在客户端控制台输入 Q 可以结束程序，向服务器发送 FIN 消息并经过四次握手过程。当然，输入 CTRL+C 也会向服务器传递 FIN 信息。强制终止程序时，由操作系统关闭文件套接字，此过程相当于调用 close 函数，也会向服务器发送 FIN 消息。 这样看不到是什么特殊现象，考虑以下情况： 服务器端和客户端都已经建立连接的状态下，向服务器控制台输入 CTRL+C ，强制关闭服务端 如果用这种方式终止程序，如果用同一端口号再次运行服务端，就会输出「bind() error」消息，并且无法再次运行。但是在这种情况下，再过大约 3 分钟就可以重新运行服务端。 9.2.2 Time-wait 状态观察以下过程： 假设图中主机 A 是服务器，因为是主机 A 向 B 发送 FIN 消息，故可想象成服务器端在控制台中输入 CTRL+C 。但是问题是，套接字经过四次握手后并没有立即消除，而是要经过一段时间的 Time-wait 状态。当然，只有先断开连接的（先发送 FIN 消息的）主机才经过 Time-wait 状态。因此，若服务器端先断开连接，则无法立即重新运行。套接字处在 Time-wait 过程时，相应端口是正在使用的状态。因此，就像之前验证过的，bind 函数调用过程中会发生错误。 实际上，不论是服务端还是客户端，都要经过一段时间的 Time-wait 过程。先断开连接的套接字必然会经过 Time-wait 过程，但是由于客户端套接字的端口是任意制定的，所以无需过多关注 Time-wait 状态。 那到底为什么会有 Time-wait 状态呢，在图中假设，主机 A 向主机 B 传输 ACK 消息（SEQ 5001 , ACK 7502 ）后立刻消除套接字。但是最后这条 ACK 消息在传递过程中丢失，没有传递主机 B ，这时主机 B 就会试图重传。但是此时主机 A 已经是完全终止状态，因为主机 B 永远无法收到从主机 A 最后传来的 ACK 消息。基于这些问题的考虑，所以要设计 Time-wait 状态。 9.2.3 地址再分配Time-wait 状态看似重要，但是不一定讨人喜欢。如果系统发生故障紧急停止，这时需要尽快重启服务起以提供服务，但因处于 Time-wait 状态而必须等待几分钟。因此，Time-wait 并非只有优点，这些情况下容易引发大问题。下图中展示了四次握手时不得不延长 Time-wait 过程的情况。 从图上可以看出，在主机 A 四次握手的过程中，如果最后的数据丢失，则主机 B 会认为主机 A 未能收到自己发送的 FIN 信息，因此重传。这时，收到的 FIN 消息的主机 A 将重启 Time-wait 计时器。因此，如果网络状况不理想， Time-wait 将持续。 解决方案就是在套接字的可选项中更改 SO_REUSEADDR 的状态。适当调整该参数，可将 Time-wait 状态下的套接字端口号重新分配给新的套接字。SO_REUSEADDR 的默认值为 0.这就意味着无法分配 Time-wait 状态下的套接字端口号。因此需要将这个值改成 1 。具体作法已在示例 reuseadr_eserver.c 给出，只需要把注释掉的东西接解除注释即可。 123optlen = sizeof(option);option = TRUE;setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;option, optlen); 此时，已经解决了上述问题。 9.3 TCP_NODELAY9.3.1 Nagle 算法为了防止因数据包过多而发生网络过载，Nagle 算法诞生了。它应用于 TCP 层。它是否使用会导致如图所示的差异： 图中展示了通过 Nagle 算法发送字符串 Nagle 和未使用 Nagle 算法的差别。可以得到一个结论。 只有接收到前一数据的 ACK 消息， Nagle 算法才发送下一数据。 TCP 套接字默认使用 Nagle 算法交换数据，因此最大限度的进行缓冲，直到收到 ACK 。左图也就是说一共传递 4 个数据包以传输一个字符串。从右图可以看出，发送数据包一共使用了 10 个数据包。由此可知，不使用 Nagle 算法将对网络流量产生负面影响。即使只传输一个字节的数据，其头信息都可能是几十个字节。因此，为了提高网络传输效率，必须使用 Nagle 算法。 Nagle 算法并不是什么情况下都适用，网络流量未受太大影响时，不使用 Nagle 算法要比使用它时传输速度快。最典型的就是「传输大文数据」。将文件数据传入输出缓冲不会花太多时间，因此，不使用 Nagle 算法，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而在无需等待 ACK 的前提下连续传输，因此可以大大提高传输速度。 所以，未准确判断数据性质时不应禁用 Nagle 算法。 9.3.2 禁用 Nagle 算法禁用 Nagle 算法应该使用： 12int opt_val = 1;setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void *)&amp;opt_val, sizeof(opt_val)); 通过 TCP_NODELAY 的值来查看Nagle 算法的设置状态。 12opt_len = sizeof(opt_val);getsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void *)&amp;opt_val, opt_len); 如果正在使用Nagle 算法，那么 opt_val 值为 0，如果禁用则为 1. 关于这个算法，可以参考这个回答：TCP连接中启用和禁用TCP_NODELAY有什么影响？ 9.4 基于 Windows 的实现暂略 9.5 习题 以下答案仅代表本人个人观点，可能不是正确答案。 下列关于 Time-wait 状态的说法错误的是？ 答：以下字体加粗的代表正确。 Time-wait 状态只在服务器的套接字中发生 断开连接的四次握手过程中，先传输 FIN 消息的套接字将进入 Time-wait 状态。 Time-wait 状态与断开连接的过程无关，而与请求连接过程中 SYN 消息的传输顺序有关 Time-wait 状态通常并非必要，应尽可能通过更改套接字可选项来防止其发生 TCP_NODELAY 可选项与 Nagle 算法有关，可通过它禁用 Nagle 算法。请问何时应考虑禁用 Nagle 算法？结合收发数据的特性给出说明。 答：当网络流量未受太大影响时，不使用 Nagle 算法要比使用它时传输速度快，比如说在传输大文件时。 第 10 章 多进程服务器端本章代码，在TCP-IP-NetworkNote中可以找到。 10.1 进程概念及应用10.1.1 并发服务端的实现方法通过改进服务端，使其同时向所有发起请求的客户端提供服务，以提高平均满意度。而且，网络程序中数据通信时间比 CPU 运算时间占比更大，因此，向多个客户端提供服务是一种有效的利用 CPU 的方式。接下来讨论同时向多个客户端提供服务的并发服务器端。下面列出的是具有代表性的并发服务端的实现模型和方法： 多进程服务器：通过创建多个进程提供服务 多路复用服务器：通过捆绑并统一管理 I/O 对象提供服务 多线程服务器：通过生成与客户端等量的线程提供服务 先是第一种方法：多进程服务器 10.1.2 理解进程进程的定义如下： 占用内存空间的正在运行的程序 假如你下载了一个游戏到电脑上，此时的游戏不是进程，而是程序。只有当游戏被加载到主内存并进入运行状态，这是才可称为进程。 10.1.3 进程 ID在说进程创建方法之前，先要简要说明进程 ID。无论进程是如何创建的，所有的进程都会被操作系统分配一个 ID。此 ID 被称为「进程ID」，其值为大于 2 的证书。1 要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户无法得到 ID 值为 1 。接下来观察在 Linux 中运行的进程。 1ps au 通过上面的命令可查看当前运行的所有进程。需要注意的是，该命令同时列出了 PID（进程ID）。参数 a 和 u列出了所有进程的详细信息。 10.1.4 通过调用 fork 函数创建进程创建进程的方式很多，此处只介绍用于创建多进程服务端的 fork 函数。 123#include &lt;unistd.h&gt;pid_t fork(void);// 成功时返回进程ID,失败时返回 -1 fork 函数将创建调用的进程副本。也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用 fork 函数的进程。另外，两个进程都执行 fork 函数调用后的语句（准确的说是在 fork 函数返回后）。但因为是通过同一个进程、复制相同的内存空间，之后的程序流要根据 fork 函数的返回值加以区分。即利用 fork 函数的如下特点区分程序执行流程。 父进程：fork 函数返回子进程 ID 子进程：fork 函数返回 0 此处，「父进程」（Parent Process）指原进程，即调用 fork 函数的主体，而「子进程」（Child Process）是通过父进程调用 fork 函数复制出的进程。接下来是调用 fork 函数后的程序运行流程。如图所示： 从图中可以看出，父进程调用 fork 函数的同时复制出子进程，并分别得到 fork 函数的返回值。但复制前，父进程将全局变量 gval 增加到 11,将局部变量 lval 的值增加到 25，因此在这种状态下完成进程复制。复制完成后根据 fork 函数的返回类型区分父子进程。父进程的 lval 的值增加 1 ，但这不会影响子进程的 lval 值。同样子进程将 gval 的值增加 1 也不会影响到父进程的 gval 。因为 fork 函数调用后分成了完全不同的进程，只是二者共享同一段代码而已。接下来给出一个例子： fork.c 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int gval = 10;int main(int argc, char *argv[])&#123; pid_t pid; int lval = 20; gval++, lval += 5; pid = fork(); if (pid == 0) gval += 2, lval += 2; else gval -= 2, lval -= 2; if (pid == 0) printf("Child Proc: [%d,%d] \n", gval, lval); else printf("Parent Proc: [%d,%d] \n", gval, lval); return 0;&#125; 编译运行： 12gcc fork.c -o fork./fork 运行结果： 可以看出，当执行了 fork 函数之后，此后就相当于有了两个程序在执行代码，对于父进程来说，fork 函数返回的是子进程的ID，对于子进程来说，fork 函数返回 0。所以这两个变量，父进程进行了 +2 操作 ，而子进程进行了 -2 操作，所以结果是这样。 10.2 进程和僵尸进程文件操作中，关闭文件和打开文件同等重要。同样，进程销毁和进程创建也同等重要。如果未认真对待进程销毁，他们将变成僵尸进程。 10.2.1 僵尸（Zombie）进程进程的工作完成后（执行完 main 函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作「僵尸进程」，这也是给系统带来负担的原因之一。 僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源 维基百科： 在类UNIX系统中，僵尸进程是指完成执行（通过exit系统调用，或运行时发生致命错误或收到终止信号所致）但在操作系统的进程表中仍然有一个表项（进程控制块PCB），处于”终止状态”的进程。这发生于子进程需要保留表项以允许其父进程读取子进程的exit status：一旦退出态通过wait系统调用读取，僵尸进程条目就从进程表中删除，称之为”回收（reaped）”。正常情况下，进程直接被其父进程wait并由系统回收。进程长时间保持僵尸状态一般是错误的并导致资源泄漏。 英文术语zombie process源自丧尸 — 不死之人，隐喻子进程已死但仍然没有被收割。与正常进程不同，kill命令对僵尸进程无效。孤儿进程不同于僵尸进程，其父进程已经死掉，但孤儿进程仍能正常执行，但并不会变为僵尸进程，因为被init（进程ID号为1）收养并wait其退出。 子进程死后，系统会发送SIGCHLD 信号给父进程，父进程对其默认处理是忽略。如果想响应这个消息，父进程通常在SIGCHLD 信号事件处理程序中，使用wait系统调用来响应子进程的终止。 僵尸进程被收割后，其进程号(PID)与在进程表中的表项都可以被系统重用。但如果父进程没有调用wait，僵尸进程将保留进程表中的表项，导致了资源泄漏。某些情况下这反倒是期望的：父进程创建了另外一个子进程，并希望具有不同的进程号。如果父进程通过设置事件处理函数为SIG_IGN显式忽略SIGCHLD信号，而不是隐式默认忽略该信号，或者具有SA_NOCLDWAIT标志，所有子进程的退出状态信息将被抛弃并且直接被系统回收。 UNIX命令ps列出的进程的状态（”STAT”）栏标示为 “Z”则为僵尸进程。[1] 收割僵尸进程的方法是通过kill命令手工向其父进程发送SIGCHLD信号。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得init进程收养僵尸进程。init进程周期执行wait系统调用收割其收养的所有僵尸进程。 10.2.2 产生僵尸进程的原因为了防止僵尸进程产生，先解释产生僵尸进程的原因。利用如下两个示例展示调用 fork 函数产生子进程的终止方式。 传递参数并调用 exit() 函数 main 函数中执行 return 语句并返回值 向 exit 函数传递的参数值和 main 函数的 return 语句返回的值都回传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进程。也就是说将子进程变成僵尸进程的正是操作系统。既然如此，僵尸进程何时被销毁呢？ 应该向创建子进程册父进程传递子进程的 exit 参数值或 return 语句的返回值。 如何向父进程传递这些值呢？操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求（函数调用）的时候，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。也就是说，父母要负责收回自己生的孩子。接下来的示例是创建僵尸进程： zombie.c 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[])&#123; pid_t pid = fork(); if (pid == 0) &#123; puts("Hi, I am a child Process"); &#125; else &#123; printf("Child Process ID: %d \n", pid); sleep(30); &#125; if (pid == 0) puts("End child proess"); else puts("End parent process"); return 0;&#125; 编译运行： 12gcc zombie.c -o zombie./zombie 结果： 因为暂停了 30 秒，所以在这个时间内可以验证一下子进程是否为僵尸进程。 通过 ps au 命令可以看出，子进程仍然存在，并没有被销毁，僵尸进程在这里显示为 Z+.30秒后，红框里面的两个进程会同时被销毁。 利用 ./zombie &amp;可以使程序在后台运行，不用打开新的命令行窗口。 10.2.3 销毁僵尸进程 1：利用 wait 函数如前所述，为了销毁子进程，父进程应该主动请求获取子进程的返回值。下面是发起请求的具体方法。有两种，下面的函数是其中一种。 12345#include &lt;sys/wait.h&gt;pid_t wait(int *statloc);/*成功时返回终止的子进程 ID ,失败时返回 -1*/ 调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit 函数的参数返回值，main 函数的 return 返回值）将保存到该函数的参数所指的内存空间。但函数参数指向的单元中还包含其他信息，因此需要用下列宏进行分离： WIFEXITED 子进程正常终止时返回「真」 WEXITSTATUS 返回子进程时的返回值 也就是说，向 wait 函数传递变量 status 的地址时，调用 wait 函数后应编写如下代码： 12345if (WIFEXITED(status))&#123; puts("Normal termination"); printf("Child pass num: %d", WEXITSTATUS(status));&#125; 根据以上内容，有如下示例： wait.c 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char *argv[])&#123; int status; pid_t pid = fork(); //这里的子进程将在第13行通过 return 语句终止 if (pid == 0) &#123; return 3; &#125; else &#123; printf("Child PID: %d \n", pid); pid = fork(); //这里的子进程将在 21 行通过 exit() 函数终止 if (pid == 0) &#123; exit(7); &#125; else &#123; printf("Child PID: %d \n", pid); wait(&amp;status); //之间终止的子进程相关信息将被保存到 status 中，同时相关子进程被完全销毁 if (WIFEXITED(status)) //通过 WIFEXITED 来验证子进程是否正常终止。如果正常终止，则调用 WEXITSTATUS 宏输出子进程返回值 printf("Child send one: %d \n", WEXITSTATUS(status)); wait(&amp;status); //因为之前创建了两个进程，所以再次调用 wait 函数和宏 if (WIFEXITED(status)) printf("Child send two: %d \n", WEXITSTATUS(status)); sleep(30); &#125; &#125; return 0;&#125; 编译运行： 12gcc wait.c -o wait./wait 结果： 此时，系统中并没有上述 PID 对应的进程，这是因为调用了 wait 函数，完全销毁了该子进程。另外两个子进程返回时返回的 3 和 7 传递到了父进程。 这就是通过 wait 函数消灭僵尸进程的方法，调用 wait 函数时，如果没有已经终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此要谨慎调用该函数。 10.2.4 销毁僵尸进程 2：使用 waitpid 函数wait 函数会引起程序阻塞，还可以考虑调用 waitpid 函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。 12345678#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *statloc, int options);/*成功时返回终止的子进程ID 或 0 ，失败时返回 -1pid: 等待终止的目标子进程的ID,若传 -1，则与 wait 函数相同，可以等待任意子进程终止statloc: 与 wait 函数的 statloc 参数具有相同含义options: 传递头文件 sys/wait.h 声明的常量 WNOHANG ,即使没有终止的子进程也不会进入阻塞状态，而是返回 0 退出函数。*/ 以下是 waitpid 的使用示例： waitpid.c 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;int main(int argc, char *argv[])&#123; int status; pid_t pid = fork(); if (pid == 0) &#123; sleep(15); //用 sleep 推迟子进程的执行 return 24; &#125; else &#123; //调用waitpid 传递参数 WNOHANG ，这样之前有没有终止的子进程则返回0 while (!waitpid(-1, &amp;status, WNOHANG)) &#123; sleep(3); puts("sleep 3 sec."); &#125; if (WIFEXITED(status)) printf("Child send %d \n", WEXITSTATUS(status)); &#125; return 0;&#125; 编译运行： 12gcc waitpid.c -o waitpid./waitpid 结果: 可以看出来，在 while 循环中正好执行了 5 次。这也证明了 waitpid 函数并没有阻塞 10.3 信号处理我们已经知道了进程的创建及销毁的办法，但是还有一个问题没有解决。 子进程究竟何时终止？调用 waitpid 函数后要无休止的等待吗？ 10.3.1 向操作系统求助子进程终止的识别主题是操作系统，因此，若操作系统能把如下信息告诉正忙于工作的父进程，将有助于构建更高效的程序 为了实现上述的功能，引入信号处理机制（Signal Handing）。此处「信号」是在特定事件发生时由操作系统向进程发送的消息。另外，为了响应该消息，执行与消息相关的自定义操作的过程被称为「处理」或「信号处理」。 10.3.2 信号与 signal 函数下面进程和操作系统的对话可以帮助理解信号处理。 进程：操作系统，如果我之前创建的子进程终止，就帮我调用 zombie_handler 函数。 操作系统：好的，如果你的子进程终止，我舅帮你调用 zombie_handler 函数，你先把要函数要执行的语句写好。 上述的对话，相当于「注册信号」的过程。即进程发现自己的子进程结束时，请求操作系统调用的特定函数。该请求可以通过如下函数调用完成： 12345678#include &lt;signal.h&gt;void (*signal(int signo, void (*func)(int)))(int);/*为了在产生信号时调用，返回之前注册的函数指针函数名: signal参数：int signo,void(*func)(int)返回类型：参数类型为int型，返回 void 型函数指针*/ 调用上述函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。下面给出可以在 signal 函数中注册的部分特殊情况和对应的函数。 SIGALRM：已到通过调用 alarm 函数注册时间 SIGINT：输入 ctrl+c SIGCHLD：子进程终止 接下来编写调用 signal 函数的语句完成如下请求： 「子进程终止则调用 mychild 函数」 此时 mychild 函数的参数应为 int ，返回值类型应为 void 。只有这样才能称为 signal 函数的第二个参数。另外，常数 SIGCHLD 定义了子进程终止的情况，应成为 signal 函数的第一个参数。也就是说，signal 函数调用语句如下： 1signal(SIGCHLD , mychild); 接下来编写 signal 函数的调用语句，分别完成如下两个请求： 已到通过 alarm 函数注册时间，请调用 timeout 函数 输入 ctrl+c 时调用 keycontrol 函数 代表这 2 种情况的常数分别为 SIGALRM 和 SIGINT ，因此按如下方式调用 signal 函数。 12signal(SIGALRM , timeout);signal(SIGINT , keycontrol); 以上就是信号注册过程。注册好信号之后，发生注册信号时（注册的情况发生时），操作系统将调用该信号对应的函数。先介绍 alarm 函数。 123#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);// 返回0或以秒为单位的距 SIGALRM 信号发生所剩时间 如果调用该函数的同时向它传递一个正整型参数，相应时间后（以秒为单位）将产生 SIGALRM 信号。若向该函数传递为 0 ，则之前对 SIGALRM 信号的预约将取消。如果通过改函数预约信号后未指定该信号对应的处理函数，则（通过调用 signal 函数）终止进程，不做任何处理。 signal.c 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void timeout(int sig) //信号处理器&#123; if (sig == SIGALRM) puts("Time out!"); alarm(2); //为了每隔 2 秒重复产生 SIGALRM 信号，在信号处理器中调用 alarm 函数&#125;void keycontrol(int sig) //信号处理器&#123; if (sig == SIGINT) puts("CTRL+C pressed");&#125;int main(int argc, char *argv[])&#123; int i; signal(SIGALRM, timeout); //注册信号及相应处理器 signal(SIGINT, keycontrol); alarm(2); //预约 2 秒候发生 SIGALRM 信号 for (i = 0; i &lt; 3; i++) &#123; puts("wait..."); sleep(100); &#125; return 0;&#125; 编译运行： 12gcc signal.c -o signal./signal 结果： 上述结果是没有任何输入的运行结果。当输入 ctrl+c 时: 就可以看到 CTRL+C pressed 的字符串。 发生信号时将唤醒由于调用 sleep 函数而进入阻塞状态的进程。 调用函数的主题的确是操作系统，但是进程处于睡眠状态时无法调用函数，因此，产生信号时，为了调用信号处理器，将唤醒由于调用 sleep 函数而进入阻塞状态的进程。而且，进程一旦被唤醒，就不会再进入睡眠状态。即使还未到 sleep 中规定的时间也是如此。所以上述示例运行不到 10 秒后就会结束，连续输入 CTRL+C 可能连一秒都不到。 简言之，就是本来系统要睡眠100秒，但是到了 alarm(2) 规定的两秒之后，就会唤醒睡眠的进程，进程被唤醒了就不会再进入睡眠状态了，所以就不用等待100秒。如果把 timeout() 函数中的 alarm(2) 注释掉，就会先输出wait...，然后再输出Time out! (这时已经跳过了第一次的 sleep(100) 秒),然后就真的会睡眠100秒，因为没有再发出 alarm(2) 的信号。 10.3.3 利用 sigaction 函数进行信号处理前面所学的内容可以防止僵尸进程，还有一个函数，叫做 sigaction 函数，他类似于 signal 函数，而且可以完全代替后者，也更稳定。之所以稳定，是因为： signal 函数在 Unix 系列的不同操作系统可能存在区别，但 sigaction 函数完全相同 实际上现在很少用 signal 函数编写程序，他只是为了保持对旧程序的兼容，下面介绍 sigaction 函数，只讲解可以替换 signal 函数的功能。 12345678#include &lt;signal.h&gt;int sigaction(int signo, const struct sigaction *act, struct sigaction *oldact);/*成功时返回 0 ，失败时返回 -1act: 对于第一个参数的信号处理函数（信号处理器）信息。oldact: 通过此参数获取之前注册的信号处理函数指针，若不需要则传递 0*/ 声明并初始化 sigaction 结构体变量以调用上述函数，该结构体定义如下： 123456struct sigaction&#123; void (*sa_handler)(int); sigset_t sa_mask; int sa_flags;&#125;; 此结构体的成员 sa_handler 保存信号处理的函数指针值（地址值）。sa_mask 和 sa_flags 的所有位初始化 0 即可。这 2 个成员用于指定信号相关的选项和特性，而我们的目的主要是防止产生僵尸进程，故省略。 下面的示例是关于 sigaction 函数的使用方法。 sigaction.c 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void timeout(int sig)&#123; if (sig == SIGALRM) puts("Time out!"); alarm(2);&#125;int main(int argc, char *argv[])&#123; int i; struct sigaction act; act.sa_handler = timeout; //保存函数指针 sigemptyset(&amp;act.sa_mask); //将 sa_mask 函数的所有位初始化成0 act.sa_flags = 0; //sa_flags 同样初始化成 0 sigaction(SIGALRM, &amp;act, 0); //注册 SIGALRM 信号的处理器。 alarm(2); //2 秒后发生 SIGALRM 信号 for (int i = 0; i &lt; 3; i++) &#123; puts("wait..."); sleep(100); &#125; return 0;&#125; 编译运行： 12gcc sigaction.c -o sigaction./sigaction 结果： 123456wait...Time out!wait...Time out!wait...Time out! 可以发现，结果和之前用 signal 函数的结果没有什么区别。以上就是信号处理的相关理论。 10.3.4 利用信号处理技术消灭僵尸进程下面利用子进程终止时产生 SIGCHLD 信号这一点，来用信号处理来消灭僵尸进程。看以下代码： remove_zomebie.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void read_childproc(int sig)&#123; int status; pid_t id = waitpid(-1, &amp;status, WNOHANG); if (WIFEXITED(status)) &#123; printf("Removed proc id: %d \n", id); //子进程的 pid printf("Child send: %d \n", WEXITSTATUS(status)); //子进程的返回值 &#125;&#125;int main(int argc, char *argv[])&#123; pid_t pid; struct sigaction act; act.sa_handler = read_childproc; sigemptyset(&amp;act.sa_mask); act.sa_flags = 0; sigaction(SIGCHLD, &amp;act, 0); pid = fork(); if (pid == 0) //子进程执行阶段 &#123; puts("Hi I'm child process"); sleep(10); return 12; &#125; else //父进程执行阶段 &#123; printf("Child proc id: %d\n", pid); pid = fork(); if (pid == 0) &#123; puts("Hi! I'm child process"); sleep(10); exit(24); &#125; else &#123; int i; printf("Child proc id: %d \n", pid); for (i = 0; i &lt; 5; i++) &#123; puts("wait"); sleep(5); &#125; &#125; &#125; return 0;&#125; 编译运行： 12gcc remove_zomebie.c -o zombie./zombie 结果： 123456789101112131415Child proc id: 11211Hi I&apos;m child processChild proc id: 11212 waitHi! I&apos;m child processwaitwaitRemoved proc id: 11211 Child send: 12 waitRemoved proc id: 11212 Child send: 24 wait 请自习观察结果，结果中的每一个空行代表间隔了5 秒，程序是先创建了两个子进程，然后子进程 10 秒之后会返回值，第一个 wait 由于子进程在执行，所以直接被唤醒，然后这两个子进程正在睡 10 秒，所以 5 秒之后第二个 wait 开始执行，又过了 5 秒，两个子进程同时被唤醒。所以剩下的 wait 也被唤醒。 所以在本程序的过程中，当子进程终止时候，会向系统发送一个信号，然后调用我们提前写好的处理函数，在处理函数中使用 waitpid 来处理僵尸进程，获取子进程返回值。 10.4 基于多任务的并发服务器10.4.1 基于进程的并发服务器模型之前的回声服务器每次只能同时向 1 个客户端提供服务。因此，需要扩展回声服务器，使其可以同时向多个客户端提供服务。下图是基于多进程的回声服务器的模型。 从图中可以看出，每当有客户端请求时（连接请求），回声服务器都创建子进程以提供服务。如果请求的客户端有 5 个，则将创建 5 个子进程来提供服务，为了完成这些任务，需要经过如下过程： 第一阶段：回声服务器端（父进程）通过调用 accept 函数受理连接请求 第二阶段：此时获取的套接字文件描述符创建并传递给子进程 第三阶段：进程利用传递来的文件描述符提供服务 10.4.2 实现并发服务器下面是基于多进程实现的并发的回声服务器的服务端，可以结合第四章的 echo_client.c 回声客户端来运行。 echo_mpserv.c 编译运行： 12gcc echo_mpserv.c -o eserver./eserver 结果： 和第四章的几乎一样，可以自己测试，此时的服务端支持同时给多个客户端进行服务，每有一个客户端连接服务端，就会多开一个子进程，所以可以同时提供服务。 10.4.3 通过 fork 函数复制文件描述符示例中给出了通过 fork 函数复制文件描述符的过程。父进程将 2 个套接字（一个是服务端套接字另一个是客户端套接字）文件描述符复制给了子进程。 调用 fork 函数时复制父进程的所有资源，但是套接字不是归进程所有的，而是归操作系统所有，只是进程拥有代表相应套接字的文件描述符。 如图所示，1 个套接字存在 2 个文件描述符时，只有 2 个文件描述符都终止（销毁）后，才能销毁套接字。如果维持图中的状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法销毁套接字（服务器套接字同样如此）。因此调用 fork 函数候，要将无关紧要的套接字文件描述符关掉，如图所示： 10.5 分割 TCP 的 I/O 程序10.5.1 分割 I/O 的优点我们已经实现的回声客户端的数据回声方式如下： 向服务器传输数据，并等待服务器端回复。无条件等待，直到接收完服务器端的回声数据后，才能传输下一批数据。 传输数据后要等待服务器端返回的数据，因为程序代码中重复调用了 read 和 write 函数。只能这么写的原因之一是，程序在 1 个进程中运行，现在可以创建多个进程，因此可以分割数据收发过程。默认分割过程如下图所示： 从图中可以看出，客户端的父进程负责接收数据，额外创建的子进程负责发送数据，分割后，不同进程分别负责输入输出，这样，无论客户端是否从服务器端接收完数据都可以进程传输。 分割 I/O 程序的另外一个好处是，可以提高频繁交换数据的程序性能，图下图所示： 根据上图显示可以看出，再网络不好的情况下，明显提升速度。 10.5.2 回声客户端的 I/O 程序分割下面是回声客户端的 I/O 分割的代码实现： echo_mpclient.c 可以配合刚才的并发服务器进行执行。 编译运行： 12gcc echo_mpclient.c -o eclient./eclient 127.0.0.1 9190 结果： 可以看出，基本和以前的一样，但是里面的内部结构却发生了很大的变化 10.6 习题 以下答案仅代表本人个人观点，可能不是正确答案。 下列关于进程的说法错误的是？ 答：以下加粗的内容为正确的 从操作系统的角度上说，进程是程序运行的单位 进程根据创建方式建立父子关系 进程可以包含其他进程，即一个进程的内存空间可以包含其他进程 子进程可以创建其他子进程，而创建出来的子进程还可以创建其他子进程，但所有这些进程只与一个父进程建立父子关系。 调用 fork 函数将创建子进程，一下关于子进程错误的是？ 答：以下加粗的内容为正确的 父进程销毁时也会同时销毁子进程 子进程是复制父进程所有资源创建出的进程 父子进程共享全局变量 通过 fork 函数创建的子进程将执行从开始到 fork 函数调用为止的代码。 创建子进程时复制父进程所有内容，此时复制对象也包含套接字文件描述符。编写程序验证复制的文件描述符整数值是否与原文件描述符数值相同。 答：代码为多进程服务器修改而来，代码：test_server.c 运行截图： 从图上可以看出，数值相同。 请说明进程变为僵尸进程的过程以及预防措施。 答：当一个父进程以fork()系统调用建立一个新的子进程后，核心进程就会在进程表中给这个子进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。而当这个子进程结束的时候（比如调用exit命令结束），其实他并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit的作用是使进程退出，但是也仅仅限于一个正常的进程变成了一个僵尸进程，并不能完全将其销毁）。预防措施：通过 wait 和 waitpid 函数加上信号函数写代码来预防。 第 11 章 进程间通信本章代码，在TCP-IP-NetworkNote中可以找到。 进程间通信，意味着两个不同的进程中可以交换数据 11.1 进程间通信的基本概念11.1.1 通过管道实现进程间通信下图是基于管道（PIPE）的进程间通信的模型： 可以看出，为了完成进程间通信，需要创建进程。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是 fork 函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。下面是创建管道的函数。 1234567#include &lt;unistd.h&gt;int pipe(int filedes[2]);/*成功时返回 0 ，失败时返回 -1filedes[0]: 通过管道接收数据时使用的文件描述符，即管道出口filedes[1]: 通过管道传输数据时使用的文件描述符，即管道入口*/ 父进程创建函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的 1 个文件描述符传递给子进程。下面的例子是关于该函数的使用方法： pipe1.c 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[])&#123; int fds[2]; char str[] = "Who are you?"; char buf[BUF_SIZE]; pid_t pid; // 调用 pipe 函数创建管道，fds 数组中保存用于 I/O 的文件描述符 pipe(fds); pid = fork(); //子进程将同时拥有创建管道获取的2个文件描述符，复制的并非管道，而是文件描述符 if (pid == 0) &#123; write(fds[1], str, sizeof(str)); &#125; else &#123; read(fds[0], buf, BUF_SIZE); puts(buf); &#125; return 0;&#125; 编译运行： 12gcc pipe1.c -o pipe1./pipe1 结果： 1Who are you? 可以从程序中看出，首先创建了一个管道，子进程通过 fds[1] 把数据写入管道，父进程从 fds[0] 再把数据读出来。可以从下图看出： 11.1.2 通过管道进行进程间双向通信下图可以看出双向通信模型： 下面是双向通信的示例： pipe2.c 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[])&#123; int fds[2]; char str1[] = "Who are you?"; char str2[] = "Thank you for your message"; char buf[BUF_SIZE]; pid_t pid; pipe(fds); pid = fork(); if (pid == 0) &#123; write(fds[1], str1, sizeof(str1)); sleep(2); read(fds[0], buf, BUF_SIZE); printf("Child proc output: %s \n", buf); &#125; else &#123; read(fds[0], buf, BUF_SIZE); printf("Parent proc output: %s \n", buf); write(fds[1], str2, sizeof(str2)); sleep(3); &#125; return 0;&#125; 编译运行： 12gcc pipe2.c -o pipe2./pipe2 结果： 12Parent proc output: Who are you?Child proc output: Thank you for your message 运行结果是正确的，但是如果注释掉第18行的代码，就会出现问题，导致一直等待下去。因为数据进入管道后变成了无主数据。也就是通过 read 函数先读取数据的进程将得到数据，即使该进程将数据传到了管道。因为，注释第18行会产生问题。第19行，自己成将读回自己在第 17 行向管道发送的数据。结果父进程调用 read 函数后，无限期等待数据进入管道。 当一个管道不满足需求时，就需要创建两个管道，各自负责不同的数据流动，过程如下图所示： 下面采用上述模型改进 pipe2.c 。 pipe3.c 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#define BUF_SIZE 30int main(int argc, char *argv[])&#123; int fds1[2], fds2[2]; char str1[] = "Who are you?"; char str2[] = "Thank you for your message"; char buf[BUF_SIZE]; pid_t pid; pipe(fds1), pipe(fds2); pid = fork(); if (pid == 0) &#123; write(fds1[1], str1, sizeof(str1)); read(fds2[0], buf, BUF_SIZE); printf("Child proc output: %s \n", buf); &#125; else &#123; read(fds1[0], buf, BUF_SIZE); printf("Parent proc output: %s \n", buf); write(fds2[1], str2, sizeof(str2)); &#125; return 0;&#125; 上面通过创建两个管道实现了功能，此时，不需要额外再使用 sleep 函数。运行结果和上面一样。 11.2 运用进程间通信11.2.1 保存消息的回声服务器下面对第 10 章的 echo_mpserv.c 进行改进，添加一个功能： 将回声客户端传输的字符串按序保存到文件中 实现该任务将创建一个新进程，从向客户端提供服务的进程读取字符串信息，下面是代码： echo_storeserv.c 编译运行： 12gcc echo_storeserv.c -o serv./serv 9190 此服务端配合第 10 章的客户端 echo_mpclient.c 使用，运行结果如下图: 从图上可以看出，服务端已经生成了文件，把客户端的消息保存可下来，只保存了10次消息。 11.3 习题 以下答案仅代表本人个人观点，可能不是正确答案。 什么是进程间通信？分别从概念和内存的角度进行说明。 答：进程间通信意味着两个不同的进程间可以交换数据。从内存上来说，就是两个进程可以访问同一个内存区域，然后通过这个内存区域数据的变化来进行通信。 进程间通信需要特殊的 IPC 机制，这是由于操作系统提供的。进程间通信时为何需要操作系统的帮助？ 答：为了进行进程间通信，需要管道的帮助，但是管道不是进程的资源，它属于从操作系统，所以，两个进程通过操作系统提供的内存空间进行通信。 「管道」是典型的 IPC 技法。关于管道，请回答以下问题： 管道是进程间交换数据的路径。如何创建此路径？由谁创建？ 答：使用 pipe 函数进行创建，由操作系统创建。父进程调用该函数时将创建管道。 为了完成进程间通信。2 个进程要同时连接管道。那2 个进程如何连接到同一管道？ 答：数组中有两个文件描述符，父子进程调用相关函数时，通过 fork 函数，把 1 个文件描述符传递给子进程。 管道允许 2 个进程间的双向通信。双向通信中需要注意哪些内容？ 答：向管道传输数据时，先读的进程会把数据取走。简言之，就是数据进入管道候会变成无主数据，所以有时候为了防止错误，需要多个管道来进程通信。 第 12 章 I/O 复用本章代码，在TCP-IP-NetworkNote中可以找到。 12.1 基于 I/O 复用的服务器端12.1.1 多进程服务端的缺点和解决方法为了构建并发服务器，只要有客户端连接请求就会创建新进程。这的确是实际操作中采用的一种方案，但并非十全十美，因为创建进程要付出很大的代价。这需要大量的运算和内存空间，由于每个进程都具有独立的内存空间，所以相互间的数据交换也要采用相对复杂的方法（IPC 属于相对复杂的通信方法） I/O 复用技术可以解决这个问题。 12.1.2 理解复用「复用」在电子及通信工程领域很常见，向这些领域的专家询问其概念，可能会得到如下答复： 在 1 个通信频道中传递多个数据（信号）的技术 「复用」的含义： 为了提高物理设备的效率，只用最少的物理要素传递最多数据时使用的技术 上述两种方法的内容完全一致。可以用纸电话模型做一个类比： 上图是一个纸杯电话系统，为了使得三人同时通话，说话时要同时对着两个纸杯，接听时也需要耳朵同时对准两个纸杯。为了完成 3 人通话，可以进行如下图的改进： 如图做出改进，就是引入了复用技术。 复用技术的优点： 减少连线长度 减少纸杯个数 即使减少了连线和纸杯的量仍然可以进行三人同时说话，但是如果碰到以下情况： 「好像不能同时说话？」 实际上，因为是在进行对话，所以很少发生同时说话的情况。也就是说，上述系统采用的是「时分复用」技术。因为说话人声频率不同，即使在同时说话也能进行一定程度上的区分（杂音也随之增多）。因此，也可以说是「频分复用技术」。 12.1.3 复用技术在服务器端的应用纸杯电话系统引入复用技术之后可以减少纸杯数量和连线长度。服务器端引入复用技术可以减少所需进程数。下图是多进程服务端的模型： 下图是引入复用技术之后的模型： 从图上可以看出，引入复用技术之后，可以减少进程数。重要的是，无论连接多少客户端，提供服务的进程只有一个。 12.2 理解 select 函数并实现服务端select 函数是最具代表性的实现复用服务器的方法。在 Windows 平台下也有同名函数，所以具有很好的移植性。 12.2.1 select 函数的功能和调用顺序使用 select 函数时可以将多个文件描述符集中到一起统一监视，项目如下： 是否存在套接字接收数据？ 无需阻塞传输数据的套接字有哪些？ 哪些套接字发生了异常？ 术语：「事件」。当发生监视项对应情况时，称「发生了事件」。 select 函数的使用方法与一般函数的区别并不大，更准确的说，他很难使用。但是为了实现 I/O 复用服务器端，我们应该掌握 select 函数，并运用于套接字编程当中。认为「select 函数是 I/O 复用的全部内容」也并不为过。select 函数的调用过程如下图所示： 12.2.2 设置文件描述符利用 select 函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。此时首先需要将要监视的文件描述符集中在一起。集中时也要按照监视项（接收、传输、异常）进行区分，即按照上述 3 种监视项分成 3 类。 利用 fd_set 数组变量执行此操作，如图所示，该数组是存有0和1的位数组。 图中最左端的位表示文件描述符 0（所在位置）。如果该位设置为 1，则表示该文件描述符是监视对象。那么图中哪些文件描述符是监视对象呢？很明显，是描述符 1 和 3。在 fd_set 变量中注册或更改值的操作都由下列宏完成。 FD_ZERO(fd_set *fdset)：将 fd_set 变量所指的位全部初始化成0 FD_SET(int fd,fd_set *fdset)：在参数 fdset 指向的变量中注册文件描述符 fd 的信息 FD_SLR(int fd,fd_set *fdset)：从参数 fdset 指向的变量中清除文件描述符 fd 的信息 FD_ISSET(int fd,fd_set *fdset)：若参数 fdset 指向的变量中包含文件描述符 fd 的信息，则返回「真」 上述函数中，FD_ISSET 用于验证 select 函数的调用结果，通过下图解释这些函数的功能： 12.2.3 设置检查（监视）范围及超时下面是 select 函数的定义： 1234567891011121314#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);/*成功时返回大于 0 的值，失败时返回 -1maxfd: 监视对象文件描述符数量readset: 将所有关注「是否存在待读取数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。writeset: 将所有关注「是否可传输无阻塞数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。exceptset: 将所有关注「是否发生异常」的文件描述符注册到 fd_set 型变量，并传递其地址值。timeout: 调用 select 函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息返回值: 发生错误时返回 -1,超时时返回0,。因发生关注的时间返回时，返回大于0的值，该值是发生事件的文件描述符数。*/ 如上所述，select 函数用来验证 3 种监视的变化情况，根据监视项声明 3 个 fd_set 型变量，分别向其注册文件描述符信息，并把变量的地址值传递到上述函数的第二到第四个参数。但在此之前（调用 select 函数之前）需要决定下面两件事： 文件描述符的监视（检查）范围是？ 如何设定 select 函数的超时时间？ 第一，文件描述符的监视范围和 select 的第一个参数有关。实际上，select 函数要求通过第一个参数传递监视对象文件描述符的数量。因此，需要得到注册在 fd_set 变量中的文件描述符数。但每次新建文件描述符时，其值就会增加 1 ，故只需将最大的文件描述符值加 1 再传递给 select 函数即可。加 1 是因为文件描述符的值是从 0 开始的。 第二，select 函数的超时时间与 select 函数的最后一个参数有关，其中 timeval 结构体定义如下： 12345struct timeval&#123; long tv_sec; long tv_usec;&#125;; 本来 select 函数只有在监视文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。通过上述结构体变量，将秒数填入 tv_sec 的成员，将微妙数填入 tv_usec 的成员，然后将结构体的地址值传递到 select 函数的最后一个参数。此时，即使文件描述符未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下， select 函数返回 0 。因此，可以通过返回值了解原因。如果不向设置超时，则传递 NULL 参数。 12.2.4 调用 select 函数查看结果select 返回正整数时，怎样获知哪些文件描述符发生了变化？向 select 函数的第二到第四个参数传递的 fd_set 变量中将产生如图所示的变化： 由图可知，select 函数调用完成候，向其传递的 fd_set 变量将发生变化。原来为 1 的所有位将变成 0，但是发生了变化的文件描述符除外。因此，可以认为值仍为 1 的位置上的文件描述符发生了变化。 12.2.5 select 函数调用示例下面是一个 select 函数的例子： select.c 编译运行： 12gcc select.c -o select./select 结果： 可以看出，如果运行后在标准输入流输入数据，就会在标准输出流输出数据，但是如果 5 秒没有输入数据，就提示超时。 12.2.6 实现 I/O 复用服务器端下面通过 select 函数实现 I/O 复用服务器端。下面是基于 I/O 复用的回声服务器端。 echo_selectserv.c 编译运行： 12gcc echo_selectserv.c -o selserv./selserv 9190 结果： 从图上可以看出，虽然只用了一个进程，但是却实现了可以和多个客户端进行通信，这都是利用了 select 的特点。 12.3 基于 Windows 的实现暂略 12.4 习题 以下答案仅代表本人个人观点，可能不是正确答案。 请解释复用技术的通用含义，并说明何为 I/O 复用。 答：通用含义：在 1 个通信频道中传递多个数据（信号）的技术。IO复用就是进程预先告诉内核需要监视的IO条件，使得内核一旦发现进程指定的一个或多个IO条件就绪，就通过进程进程处理，从而不会在单个IO上阻塞了。 参考文章：Linux网络编程-IO复用技术 多进程并发服务器的缺点有哪些？如何在 I/O 复用服务器中弥补？ 答：多进程需要进行大量的运算和大量的内存空间。在 I/O 复用服务器中通过 select 函数监视文件描述符，通过判断变化的文件描述符，来得知变化的套接字是哪个，从而实时应答来自多个客户端的请求。 复用服务器端需要 select 函数。下列关于 select 函数使用方法的描述错误的是？ 答：以下加粗的为正确的描述。 调用 select 函数前需要集中 I/O 监视对象的文件描述符 若已通过 select 函数注册为监视对象，则后续调用 select 函数时无需重复注册 复用服务器端同一时间只能服务于 1 个客户端，因此，需要服务的客户端接入服务器端后只能等待 与多线程服务端不同，基于 select 的复用服务器只需要 1 个进程。因此，可以减少因创建多进程产生的服务器端的负担。 select 函数的观察对象中应包含服务端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因。 答：应该包含到「是否存在待读取数据」，因为服务器端需要查看套接字中有没有可以读取的数据。 第 13 章 多种 I/O 函数本章代码，在TCP-IP-NetworkNote中可以找到。 13.1 send &amp; recv 函数13.1.1 Linux 中的 send &amp; recv首先看 sned 函数定义： 123456789#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);/*成功时返回发送的字节数，失败时返回 -1sockfd: 表示与数据传输对象的连接的套接字和文件描述符buf: 保存带传输数据的缓冲地址值nbytes: 待传输字节数flags: 传输数据时指定的可选项信息*/ 下面是 recv 函数的定义： 123456789#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);/*成功时返回接收的字节数（收到 EOF 返回 0），失败时返回 -1sockfd: 表示数据接受对象的连接的套接字文件描述符buf: 保存接受数据的缓冲地址值nbytes: 可接收的最大字节数flags: 接收数据时指定的可选项参数*/ send 和 recv 函数都是最后一个参数是收发数据的可选项，该选项可以用位或（bit OR）运算符（| 运算符）同时传递多个信息。 send &amp; recv 函数的可选项意义： 可选项（Option） 含义 send recv MSG_OOB 用于传输带外数据（Out-of-band data） O O MSG_PEEK 验证输入缓冲中是否存在接受的数据 X O MSG_DONTROUTE 数据传输过程中不参照本地路由（Routing）表，在本地（Local）网络中寻找目的地 O X MSG_DONTWAIT 调用 I/O 函数时不阻塞，用于使用非阻塞（Non-blocking）I/O O O MSG_WAITALL 防止函数返回，直到接收到全部请求的字节数 X O 13.1.2 MSG_OOB：发送紧急消息MSG_OOB 可选项用于创建特殊发送方法和通道以发送紧急消息。下面为 MSG_OOB 的示例代码： oob_recv.c oob_send.c 编译运行： 12gcc oob_send.c -o sendgcc oob_recv.c -o recv 运行结果： 从运行结果可以看出，send 是客户端，recv 是服务端，客户端给服务端发送消息，服务端接收完消息之后显示出来。可以从图中看出，每次运行的效果，并不是一样的。 代码中关于: 1fcntl(recv_sock, F_SETOWN, getpid()); 的意思是： 文件描述符 recv_sock 指向的套接字引发的 SIGURG 信号处理进程变为 getpid 函数返回值用作 ID 进程. 上述描述中的「处理 SIGURG 信号」指的是「调用 SIGURG 信号处理函数」。但是之前讲过，多个进程可以拥有 1 个套接字的文件描述符。例如，通过调用 fork 函数创建子进程并同时复制文件描述符。此时如果发生 SIGURG 信号，应该调用哪个进程的信号处理函数呢？可以肯定的是，不会调用所有进程的信号处理函数。因此，处理 SIGURG 信号时必须指定处理信号所用的进程，而 getpid 返回的是调用此函数的进程 ID 。上述调用语句指当前为处理 SIGURG 信号的主体。 输出结果，可能出乎意料： 通过 MSG_OOB 可选项传递数据时只返回 1 个字节，而且也不快 的确，通过 MSG_OOB 并不会加快传输速度，而通过信号处理函数 urg_handler 也只能读取一个字节。剩余数据只能通过未设置 MSG_OOB 可选项的普通输入函数读取。因为 TCP 不存在真正意义上的「外带数据」。实际上，MSG_OOB 中的 OOB 指的是 Out-of-band ，而「外带数据」的含义是： 通过去完全不同的通信路径传输的数据 即真正意义上的 Out-of-band 需要通过单独的通信路径高速传输数据，但是 TCP 不另外提供，只利用 TCP 的紧急模式（Urgent mode）进行传输。 13.1.3 紧急模式工作原理MSG_OOB 的真正意义在于督促数据接收对象尽快处理数据。这是紧急模式的全部内容，而 TCP 「保持传输顺序」的传输特性依然成立。TCP 的紧急消息无法保证及时到达，但是可以要求急救。下面是 MSG_OOB 可选项状态下的数据传输过程，如图： 上面是: 1send(sock, "890", strlen("890"), MSG_OOB); 图上是调用这个函数的缓冲状态。如果缓冲最左端的位置视作偏移量 0 。字符 0 保存于偏移量 2 的位置。另外，字符 0 右侧偏移量为 3 的位置存有紧急指针（Urgent Pointer）。紧急指针指向紧急消息的下一个位置（偏移量加一），同时向对方主机传递一下信息： 紧急指针指向的偏移量为 3 之前的部分就是紧急消息。 也就是说，实际上只用了一个字节表示紧急消息。这一点可以通过图中用于传输数据的 TCP 数据包（段）的结构看得更清楚，如图： TCP 数据包实际包含更多信息。TCP 头部包含如下两种信息： URG=1：载有紧急消息的数据包 URG指针：紧急指针位于偏移量为 3 的位置。 指定 MSG_OOB 选项的数据包本身就是紧急数据包，并通过紧急指针表示紧急消息所在的位置。 紧急消息的意义在于督促消息处理，而非紧急传输形式受限的信息。 13.1.4 检查输入缓冲同时设置 MSG_PEEK 选项和 MSG_DONTWAIT 选项，以验证输入缓冲是否存在接收的数据。设置 MSG_PEEK 选项并调用 recv 函数时，即使读取了输入缓冲的数据也不会删除。因此，该选项通常与 MSG_DONTWAIT 合作，用于调用以非阻塞方式验证待读数据存与否的函数。下面的示例是二者的含义： peek_recv.c peek_send.c 编译运行： 1234gcc peek_recv.c -o recvgcc peek_send.c -o send./recv 9190./send 127.0.0.1 9190 结果： 可以通过结果验证，仅发送了一次的数据被读取了 2 次，因为第一次调用 recv 函数时设置了 MSG_PEEK 可选项。 13.2 readv &amp; writev 函数13.2.1 使用 readv &amp; writev 函数readv &amp; writev 函数的功能可概括如下： 对数据进行整合传输及发送的函数 也就是说，通过 writev 函数可以将分散保存在多个缓冲中的数据一并发送，通过 readv 函数可以由多个缓冲分别接收。因此，适用这 2 个函数可以减少 I/O 函数的调用次数。下面先介绍 writev 函数。 12345678#include &lt;sys/uio.h&gt;ssize_t writev(int filedes, const struct iovec *iov, int iovcnt);/*成功时返回发送的字节数，失败时返回 -1filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 read 一样向向其传递文件或标准输出描述符.iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送数据的位置和大小信息iovcnt: 向第二个参数传递数组长度*/ 上述第二个参数中出现的数组 iovec 结构体的声明如下： 12345struct iovec&#123; void *iov_base; //缓冲地址 size_t iov_len; //缓冲大小&#125;; 下图是该函数的使用方法： writev 的第一个参数，是文件描述符，因此向控制台输出数据，ptr 是存有待发送数据信息的 iovec 数组指针。第三个参数为 2，因此，从 ptr 指向的地址开始，共浏览 2 个 iovec 结构体变量，发送这些指针指向的缓冲数据。 下面是 writev 函数的使用方法： writev.c 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;sys/uio.h&gt;int main(int argc, char *argv[])&#123; struct iovec vec[2]; char buf1[] = "ABCDEFG"; char buf2[] = "1234567"; int str_len; vec[0].iov_base = buf1; vec[0].iov_len = 3; vec[1].iov_base = buf2; vec[1].iov_len = 4; str_len = writev(1, vec, 2); puts(""); printf("Write bytes: %d \n", str_len); return 0;&#125; 编译运行： 12gcc writev.c -o writev./writevi 结果： 12ABC1234Write bytes: 7 下面介绍 readv 函数，功能和 writev 函数正好相反.函数为： 12345678#include &lt;sys/uio.h&gt;ssize_t readv(int filedes, const struct iovc *iov, int iovcnt);/*成功时返回接收的字节数，失败时返回 -1filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 read 一样向向其传递文件或标准输出描述符.iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送数据的位置和大小信息iovcnt: 向第二个参数传递数组长度*/ 下面是示例代码： readv.c 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;sys/uio.h&gt;#define BUF_SIZE 100int main(int argc, char *argv[])&#123; struct iovec vec[2]; char buf1[BUF_SIZE] = &#123; 0, &#125;; char buf2[BUF_SIZE] = &#123; 0, &#125;; int str_len; vec[0].iov_base = buf1; vec[0].iov_len = 5; vec[1].iov_base = buf2; vec[1].iov_len = BUF_SIZE; str_len = readv(0, vec, 2); printf("Read bytes: %d \n", str_len); printf("First message: %s \n", buf1); printf("Second message: %s \n", buf2); return 0;&#125; 编译运行： 12gcc readv.c -o rv./rv 运行结果： 从图上可以看出，首先截取了长度为 5 的数据输出，然后再输出剩下的。 13.2.2 合理使用 readv &amp; writev 函数实际上，能使用该函数的所有情况都适用。例如，需要传输的数据分别位于不同缓冲（数组）时，需要多次调用 write 函数。此时可通过 1 次 writev 函数调用替代操作，当然会提高效率。同样，需要将输入缓冲中的数据读入不同位置时，可以不必多次调用 read 函数，而是利用 1 次 readv 函数就能大大提高效率。 其意义在于减少数据包个数。假设为了提高效率在服务器端明确禁用了 Nagle 算法。其实 writev 函数在不采用 Nagle 算法时更有价值，如图： 13.3 基于 Windows 的实现暂略 13.4 习题 以下答案仅代表本人个人观点，可能不是正确答案。 下列关于 MSG_OOB 可选项的说法错误的是？ 答：以下加粗的字体代表说法正确。 MSG_OOB 指传输 Out-of-band 数据，是通过其他路径高速传输数据 MSG_OOB 指通过其他路径高速传输数据，因此 TCP 中设置该选项的数据先到达对方主机 设置 MSG_OOB 是数据先到达对方主机后，以普通数据的形式和顺序读取。也就是说，只是提高了传输速度，接收方无法识别这一点。 MSG_OOB 无法脱离 TCP 的默认数据传输方式，即使脱离了 MSG_OOB ，也会保持原有的传输顺序。该选项只用于要求接收方紧急处理。 利用 readv &amp; writev 函数收发数据有何优点？分别从函数调用次数和 I/O 缓冲的角度给出说明。 答：需要传输的数据分别位于不同缓冲（数组）时，需要多次调用 write 函数。此时可通过 1 次 writev 函数调用替代操作，当然会提高效率。同样，需要将输入缓冲中的数据读入不同位置时，可以不必多次调用 read 函数，而是利用 1 次 readv 函数就能大大提高效率。 通过 recv 函数验证输入缓冲中是否存在数据时（确认后立即返回时），如何设置 recv 函数最后一个参数中的可选项？分别说明各可选项的含义。 答：使用 MSG_PEEK 来验证输入缓冲中是否存在待接收的数据。各个可选项的意义参见上面对应章节的表格。 第 14 章 多播与广播本章代码，在TCP-IP-NetworkNote中可以找到。 14.1 多播多播（Multicast）方式的数据传输是基于 UDP 完成的。因此 ，与 UDP 服务器端/客户端的实现方式非常接近。区别在于，UDP 数据传输以单一目标进行，而多播数据同时传递到加入（注册）特定组的大量主机。换言之，采用多播方式时，可以同时向多个主机传递数据。 14.1.1 多播的数据传输方式以及流量方面的优点多播的数据传输特点可整理如下： 多播服务器端针对特定多播组，只发送 1 次数据。 即使只发送 1 次数据，但该组内的所有客户端都会接收数据 多播组数可以在 IP 地址范围内任意增加 多播组是 D 类IP地址（224.0.0.0~239.255.255.255），「加入多播组」可以理解为通过程序完成如下声明： 在 D 类IP地址中，我希望接收发往目标 239.234.218.234 的多播数据 多播是基于 UDP 完成的，也就是说，多播数据包的格式与 UDP 数据包相同。只是与一般的 UDP 数据包不同。向网络传递 1 个多播数据包时，路由器将复制该数据包并传递到多个主机。像这样，多播需要借助路由器完成。如图所示： 若通过 TCP 或 UDP 向 1000 个主机发送文件，则共需要传递 1000 次。但是此时如果用多播网络传输文件，则只需要发送一次。这时由 1000 台主机构成的网络中的路由器负责复制文件并传递到主机。就因为这种特性，多播主要用于「多媒体数据实时传输」。 另外，理论上可以完成多播通信，但是不少路由器并不支持多播，或即便支持也因网络拥堵问题故意阻断多播。因此，为了在不支持多播的路由器中完成多播通信，也会使用隧道（Tunneling）技术。 14.1.2 路由（Routing）和 TTL（Time to Live,生存时间），以及加入组的办法为了传递多播数据包，必须设置 TTL 。TTL 是 Time to Live的简写，是决定「数据包传递距离」的主要因素。TTL 用整数表示，并且每经过一个路由器就减一。TTL 变为 0 时，该数据包就无法再被传递，只能销毁。因此，TTL 的值设置过大将影响网络流量。当然，设置过小，也无法传递到目标。 接下来是 TTL 的设置方法。TTL 是可以通过第九章的套接字可选项完成的。与设置 TTL 相关的协议层为 IPPROTO_IP ，选项名为 IP_MULTICAST_TTL。因此，可以用如下代码把 TTL 设置为 64 123456int send_sock;int time_live = 64;...send_sock=socket(PF_INET,SOCK_DGRAM,0);setsockopt(send_sock,IPPROTO_IP,IP_MULTICAST_TTL,(void*)&amp;time_live,sizeof(time_live);... 加入多播组也通过设置设置套接字可选项来完成。加入多播组相关的协议层为 IPPROTO_IP，选项名为 IP_ADD_MEMBERSHIP 。可通过如下代码加入多播组： 123456789int recv_sock;struct ip_mreq join_adr;...recv_sock=socket(PF_INET,SOCK_DGRAM,0);...join_adr.imr_multiaddr.s_addr="多播组地址信息";join_adr.imr_interface.s_addr="加入多播组的主机地址信息";setsockopt(recv_sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(void*)&amp;join_adr,sizeof(time_live);... 下面是 ip_mreq 结构体的定义： 12345struct ip_mreq&#123; struct in_addr imr_multiaddr; //写入加入组的IP地址 struct in_addr imr_interface; //加入该组的套接字所属主机的IP地址&#125;; 14.1.3 实现多播 Sender 和 Receiver多播中用「发送者」（以下称为 Sender） 和「接收者」（以下称为 Receiver）替代服务器端和客户端。顾名思义，此处的 Sender 是多播数据的发送主体，Receiver 是需要多播组加入过程的数据接收主体。下面是示例，示例的运行场景如下： Sender : 向 AAA 组广播（Broadcasting）文件中保存的新闻信息 Receiver : 接收传递到 AAA 组的新闻信息。 下面是两个代码： news_sender.c news_receiver.c 编译运行： 1234gcc news_sender.c -o sendergcc news_receiver.c -o receiver./sender 224.1.1.2 9190./receiver 224.1.1.2 9190 结果： 通过结果可以看出，使用 sender 多播信息，通过 receiver 接收广播，如果延迟运行 receiver 将无法接受之前发送的信息。 14.2 广播广播（Broadcast）在「一次性向多个主机发送数据」这一点上与多播类似，但传输数据的范围有区别。多播即使在跨越不同网络的情况下，只要加入多播组就能接受数据。相反，广播只能向同一网络中的主机传输数据。 14.2.1 广播的理解和实现方法广播是向同一网络中的所有主机传输数据的方法。与多播相同，广播也是通过 UDP 来完成的。根据传输数据时使用的IP地址形式，广播分为以下两种： 直接广播（Directed Broadcast） 本地广播（Local Broadcast） 二者在实现上的差别主要在于IP地址。直接广播的IP地址中除了网络地址外，其余主机地址全部设置成 1。例如，希望向网络地址 192.12.34 中的所有主机传输数据时，可以向 192.12.34.255 传输。换言之，可以采取直接广播的方式向特定区域内所有主机传输数据。 反之，本地广播中使用的IP地址限定为 255.255.255.255 。例如，192.32.24 网络中的主机向 255.255.255.255 传输数据时，数据将传输到 192.32.24 网络中所有主机。 数据通信中使用的IP地址是与 UDP 示例的唯一区别。默认生成的套接字会阻止广播，因此，只需通过如下代码更改默认设置。 1234567int send_sock;int bcast;...send_sock=socket(PF_INET,SOCK_DGRAM,0);...setsockopt(send_sock,SOL_SOCKET,SO_BROADCAST,(void*)&amp;bcast,sizeof(bcast));... 14.2.2 实现广播数据的 Sender 和 Receiver下面是广播数据的 Sender 和 Receiver的代码： news_sender_brd.c news_receiver_brd.c 编译运行： 1234gcc news_receiver_brd.c -o receivergcc news_sender_brd.c -o sender./sender 255.255.255.255 9190./receiver 9190 结果： 14.3 基于 Windows 的实现暂略 14.4 习题 以下答案仅代表本人个人观点，可能不是正确答案。 TTL 的含义是什么？请从路由器的角度说明较大的 TTL 值与较小的 TTL 值之间的区别及问题。 答：TTL 是决定「数据包传递距离」的主要因素。TTL 每经过一个路由器就减一。TTL 变为 0 时，数据包就无法再被传递，只能销毁。因此，TTL设置过大会影响网络流量。当然，设置过小无法传递到目标。 多播与广播的异同点是什么？请从数据通信的角度进行说明。 答：在「一次性向多个主机发送数据」这一点上与多播类似，但传输的数据范围有区别。多播即使在跨越不同网络的情况下，只要加入多播组就能接受数据。相反，广播只能向同意网络中的主机传输数据。 下面关于多播的说法描述错误的是？ 答：以下内容加粗的为描述正确 多播是用来加入多播组的所有主机传输数据的协议 主机连接到同一网络才能加入到多播组，也就是说，多播组无法跨越多个网络 能够加入多播组的主机数并无限制，但只能有 1个主机（Sender）向该组发送数据 多播时使用的套接字是 UDP 套接字，因为多播是基于 UDP 进行数据通信的。 多播也对网络流量有利，请比较 TCP 交换方式解释其原因 答：TCP 是必须建立一对一的连接，如果要向1000个主机发送文件，就得传递1000次。但是此时用多播方式传输数据，就只需要发送一次。 多播方式的数据通信需要 MBone 虚拟网络。换言之，MBone 是用于多播的网络，但它是虚拟网络。请解释此处的「虚拟网络」 答：可以理解为「通过网络中的特殊协议工作的软件概念上的网络」。也就是说， MBone 并非可以触及的物理网络。他是以物理网络为基础，通过软件方法实现的多播通信必备虚拟网络。 转自《TCP/IP网络编程》【韩】尹圣雨 著 金国哲 译]]></content>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Basic Level) Practice]]></title>
    <url>%2F2019%2F08%2F05%2FPAT-Basic-Level-Practice%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;下半年会陆续考乙级和甲级，今天刚刷完乙级的所有题目，想着来总结一下，觉着一个一个分开写太麻烦，于是就这篇博客将所有题目放在一起进行总结。 1001 害死人不偿命的(3n+1)猜想原题链接 分析：ans从0开始统计需要的步数，(n &amp; 1)不为0 表示n为奇数，当n为奇数，就令n = 3*n+1；偶数将其砍掉一半，步数ans++，直到n == 1为止，最后输出ans即可 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, ans = 0; cin &gt;&gt; n; while (n != 1) &#123; if (n &amp; 1) &#123; n = (3 * n + 1) / 2; ans++; &#125; else &#123; n /= 2; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 1002 写出这个数原题链接 分析：由于n很大，所以我们用string接收输入，将string的每一位数字累加到sum里面，再将sum转化为string类型的num，对num的每一位输出对应中文拼音 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - '0'); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; " "; cout &lt;&lt; str[num[i] - '0']; &#125; return 0;&#125; 1004 成绩排名原题链接 分析：将姓名、学号、成绩用一个结构体存储，然后自定义cmp按照成绩升序排序，然后直接输出最后一个元素和第一个元素的信息即可。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; string name; string id; int mark;&#125;;bool cmp(node x, node y) &#123; return x.mark &lt; y.mark; &#125;int main() &#123; int n; cin &gt;&gt; n; node nd[n + 5]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nd[i].name &gt;&gt; nd[i].id &gt;&gt; nd[i].mark; &#125; sort(nd, nd + n, cmp); cout &lt;&lt; nd[n - 1].name &lt;&lt; " " &lt;&lt; nd[n - 1].id &lt;&lt; endl; cout &lt;&lt; nd[0].name &lt;&lt; " " &lt;&lt; nd[0].id &lt;&lt; endl; return 0;&#125; 1005 继续(3n+1)猜想原题链接 分析：对每个数可能产生的被其覆盖的数全部放入一个set里，然后将a按升序排列，从后往前输出，若是在set里找不到此时的a[i]，那么它就是关键数放入key数组中，最后输出key数组即可。(se.find(a[i]) == se.end())代表set里面找不到。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; se;int main() &#123; int n, t; cin &gt;&gt; n; int a[n + 5] = &#123;0&#125;, key[n + 5] = &#123;0&#125;; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; ++i) &#123; t = a[i]; while (t != 1) &#123; if (t &amp; 1) &#123; t = (3 * t + 1) / 2; se.insert(t); &#125; else &#123; t /= 2; se.insert(t); &#125; &#125; &#125; sort(a, a + n); int ret = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; if (se.find(a[i]) == se.end()) key[ret++] = a[i]; &#125; for (int i = 0; i &lt; ret; ++i) &#123; if (i != ret - 1) &#123; cout &lt;&lt; key[i] &lt;&lt; " "; &#125; else &#123; cout &lt;&lt; key[i] &lt;&lt; endl; &#125; &#125; return 0;&#125; 1006 换个格式输出整数原题链接 分析：用a,b,c分别存储百、十、个的个数然后循环输出即可。 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int a = n / 100; int b = n / 10 % 10; int c = n % 10; for (int i = 0; i &lt; a; i++) cout &lt;&lt; "B"; for (int i = 0; i &lt; b; i++) cout &lt;&lt; "S"; for (int i = 0; i &lt; c; i++) cout &lt;&lt; i + 1; return 0;&#125; 1007 素数对猜想原题链接 分析：直接素数打表，然后如果prime[i]和prime[i + 2]都是素数的话sum++。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 5;bool prime[MAXN + 5];int sum = 0, n;void Prime() &#123; for (int i = 2; i &lt;= MAXN; i++) prime[i] = true; for (int i = 2; i * i &lt;= MAXN; i++) &#123; if (prime[i]) &#123; for (int j = i * i; j &lt;= MAXN; j += i) prime[j] = false; &#125; &#125; for (int i = 2; i &lt;= MAXN; i++) &#123; if (prime[i] &amp;&amp; prime[i + 2]) &#123; if (i + 2 &gt; n) break; sum++; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123; cin &gt;&gt; n; Prime(); return 0;&#125; 1008 数组元素循环右移问题原题链接 分析：调用list模拟题目过程。back() 返回最后一个元素front() 返回第一个元素pop_back() 删除最后一个元素pop_front() 删除第一个元素push_back() 在list的末尾添加一个元素push_front() 在list的头部添加一个元素需要注意的是类似pop_back()这种是没有返回值的，java是有的，在c++里要想获得头部元素或者尾部元素只能用back()和front()。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;list&lt;int&gt; ls;int main() &#123; int n, m, t; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; t; ls.push_back(t); &#125; while (m--) &#123; t = ls.back(); ls.pop_back(); ls.push_front(t); &#125; t = 0; while (ls.size() &gt; 0) &#123; if (t == 0) cout &lt;&lt; ls.front(); else cout &lt;&lt; " " &lt;&lt; ls.front(); t = 1; ls.pop_front(); &#125; return 0;&#125; 1009 说反话原题链接分析：用cin接收每个单词，放入vector中，然后逆序输出vector即可。 输入结束时，在OJ里面会在输入文件结束后自动结束，如果是在IDE里面测试，会需要按ctrl + d手动结束输入；Java的话用好nextLine和split即可。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;string&gt; v; string s = ""; while (cin &gt;&gt; s) v.push_back(s); for (int i = v.size() - 1; i &gt;= 0; --i) &#123; if (i == v.size() - 1) &#123; cout &lt;&lt; v[i]; continue; &#125; cout &lt;&lt; " " &lt;&lt; v[i]; &#125; system("pause"); return 0;&#125; 12345678910111213import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); String str = cin.nextLine(); String[] words = str.split(" "); for (int i = words.length - 1; i &gt;= 0; i--) &#123; if (i != 0) System.out.print(words[i] + " "); else System.out.println(words[i]); &#125; &#125;&#125; 1010 一元多项式求导原题链接 分析：每次对输入的两个数进行计算，记得考虑输入的只是常数项的情况，这个时候是要输出”0 0”的 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; bool ok = false; int a, b; while (cin &gt;&gt; a &gt;&gt; b) &#123; if (b != 0) &#123; if (ok) cout &lt;&lt; " "; cout &lt;&lt; a * b &lt;&lt; " " &lt;&lt; b - 1; ok = true; &#125; &#125; if (!ok) cout &lt;&lt; "0 0"; return 0;&#125; 1011 A+B 和 C原题链接 分析：用long long int存储a、b和c，当a + b &gt; c的时候输出true，否则输出false 123456789101112#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main() &#123; ll n, a, b, c; scanf("%lld", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%lld%lld%lld", &amp;a, &amp;b, &amp;c); printf("Case #%d: %s\n", i + 1, a + b &gt; c ? "true" : "false"); &#125; return 0;&#125; 1012 数字分类原题链接 分析：按题意模拟即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int a[1005];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; int a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0, x = 0, ret = 1; bool ok1 = false, ok2 = false, ok3 = false, ok4 = false, ok5 = false; for (int i = 0; i &lt; n; ++i) &#123; if (a[i] % 5 == 0 &amp;&amp; !(a[i] &amp; 1)) &#123; ok1 = true; a1 += a[i]; &#125; if (a[i] % 5 == 1) &#123; ok2 = true; a2 += (a[i] * ret); ret *= -1; &#125; if (a[i] % 5 == 2) &#123; ok3 = true; a3++; &#125; if (a[i] % 5 == 3) &#123; ok4 = true; x += a[i]; a4++; &#125; if (a[i] % 5 == 4) &#123; ok5 = true; a5 = max(a5, a[i]); &#125; &#125; if (ok1) cout &lt;&lt; a1 &lt;&lt; " "; else cout &lt;&lt; "N "; if (ok2) cout &lt;&lt; a2 &lt;&lt; " "; else cout &lt;&lt; "N "; if (ok3) cout &lt;&lt; a3 &lt;&lt; " "; else cout &lt;&lt; "N "; if (ok4) printf("%.1f ", x * 1.0 / a4); else cout &lt;&lt; "N "; if (ok5) cout &lt;&lt; a5; else cout &lt;&lt; "N"; return 0;&#125; 1013 数素数原题链接 分析：素数打表，a数组存素数的值，用cnt标记输出了多少个，如果当前已经输出的个数为10，将cnt置为1。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;const int N = 1e6;bool prime[N + 5];int a[N + 5];void Prime() &#123; for (int i = 2; i &lt;= N; ++i) prime[i] = true; for (int i = 2; i * i &lt;= N; ++i) &#123; if (prime[i]) &#123; for (int j = i * i; j &lt;= N; j += i) prime[j] = false; &#125; &#125; int ret = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (prime[i]) a[ret++] = i; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; Prime(); int cnt = 1; for (int i = n; i &lt;= m; ++i) &#123; if (i == m) &#123; cout &lt;&lt; a[i] &lt;&lt; endl; &#125; else if (cnt != 10) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; cnt++; &#125; else &#123; cout &lt;&lt; a[i] &lt;&lt; endl; cnt = 1; &#125; &#125; return 0;&#125; 1014 福尔摩斯的约会原题链接 分析：按照题意找到相等的字符后判断即可，如果输出的时间不足2位数要在前面添0，即用%02d输出。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;string day[] = &#123;"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"&#125;;int main() &#123; string s1 = "", s2 = "", s3 = "", s4 = ""; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4; int a = -1, b = -1, c = -1, i, j; for (i = 0; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); ++i) &#123; if (s1[i] == s2[i] &amp;&amp; (s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'G')) &#123; a = s1[i] - 'A'; break; &#125; &#125; i++; for (; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); ++i) &#123; if (s1[i] == s2[i] &amp;&amp; ((s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'N') || isdigit(s1[i]))) &#123; b = isdigit(s1[i]) ? s1[i] - '0' : s1[i] - 'A' + 10; break; &#125; &#125; for (j = 0; j &lt; s3.length() &amp;&amp; j &lt; s4.length(); ++j) &#123; if (s3[j] == s4[j] &amp;&amp; isalpha(s3[j])) &#123; c = j; break; &#125; &#125; cout &lt;&lt; day[a] &lt;&lt; " "; printf("%02d:%02d", b, c); return 0;&#125; 1015 德才论原题链接 分析：首先用结构体存储准考证号、德分、才分，再根据题意写好cmp函数，结构体数组vector v[4]中v[0]保存第一类考生，v[1]保存第二类考生，最后依次sort之后遍历这四个vector输出答案即可。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int id, de, cai;&#125; nd;bool cmp(node x, node y) &#123; if ((x.de + x.cai) == (y.de + y.cai)) &#123; if (x.de == y.de) return x.id &lt; y.id; return x.de &gt; y.de; &#125; return (x.de + x.cai) &gt; (y.de + y.cai);&#125;int main() &#123; int n, low, high, num = 0; scanf("%d%d%d", &amp;n, &amp;low, &amp;high); vector&lt;node&gt; v[4]; num = n; for (int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;nd.id, &amp;nd.de, &amp;nd.cai); if (nd.de &lt; low || nd.cai &lt; low) &#123; num--; &#125; else if (nd.de &gt;= high &amp;&amp; nd.cai &gt;= high) &#123; v[0].push_back(nd); //才德全尽 &#125; else if (nd.de &gt;= high &amp;&amp; nd.cai &lt; high) &#123; v[1].push_back(nd); //德胜才 &#125; else if (nd.de &lt; high &amp;&amp; nd.cai &lt; high &amp;&amp; nd.de &gt;= nd.cai) &#123; v[2].push_back(nd); //“才德兼亡”但尚有“德胜才” &#125; else &#123; v[3].push_back(nd); &#125; &#125; printf("%d\n", num); for (int i = 0; i &lt; 4; ++i) &#123; sort(v[i].begin(), v[i].end(), cmp); for (int j = 0; j &lt; v[i].size(); ++j) &#123; printf("%d %d %d\n", v[i][j].id, v[i][j].de, v[i][j].cai); &#125; &#125; return 0;&#125; 1016 部分A+B原题链接 分析：A和B用字符串存储，模拟即可。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string a, b; int da, db, pa = 0, pb = 0; cin &gt;&gt; a &gt;&gt; da &gt;&gt; b &gt;&gt; db; for (int i = 0; i &lt; a.length(); i++) &#123; if (da == (a[i] - '0')) pa = pa * 10 + da; &#125; for (int i = 0; i &lt; b.length(); i++) &#123; if (db == (b[i] - '0')) pb = pb * 10 + db; &#125; cout &lt;&lt; pa + pb &lt;&lt; endl; return 0;&#125; 1019 数字黑洞原题链接 分析：用数组存储每一位，然后每次对得到的n分给数组的每一位，sort一下，用y存储大的，用x存储小的，若y - x == 6174就break即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int a[4];int main() &#123; int n, x, y; cin &gt;&gt; n; while (n != 0) &#123; memset(a, 0, sizeof(a)); a[0] = n / 1000, a[1] = n / 100 % 10, a[2] = n / 10 % 10, a[3] = n % 10; //千百十个 sort(a, a + n); x = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3]; y = a[3] * 1000 + a[2] * 100 + a[1] * 10 + a[0]; n = y - x; printf("%04d - %04d = %04d\n", y, x, n); if (n == 6174) break; &#125; return 0;&#125; 1020 月饼原题链接 分析：简单贪心，要想收益最大，那么我们需要优先卖出单价高的月饼，所以我们自定义cmp以单价从大到小排序，然后从1~n遍历，如果此时月饼的库存&lt;=最大需求量，那么收益+=这款月饼的总售价，否则收益+=需求量*单价。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; double stock, value, unit;&#125; ck[1005];bool cmp(node x, node y) &#123; return x.unit &gt; y.unit; &#125;int main() &#123; int n, d; cin &gt;&gt; n &gt;&gt; d; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; ck[i].stock; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; ck[i].value; for (int i = 0; i &lt; n; ++i) ck[i].unit = ck[i].value * 1.0 / ck[i].stock; sort(ck, ck + n, cmp); double revenue = 0.0; for (int i = 0; i &lt; n; ++i) &#123; if (ck[i].stock &lt;= d) &#123; revenue += ck[i].value; d -= ck[i].stock; &#125; else &#123; revenue += ck[i].unit * d; break; &#125; &#125; printf("%.2lf\n", revenue); return 0;&#125; 1021 个位数统计原题链接 分析：用数组存每一位出现的次数即可，类似桶排序。 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int a[10];int main() &#123; string s; cin &gt;&gt; s; for (int i = 0; i &lt; s.length(); ++i) a[s[i] - '0']++; for (int i = 0; i &lt; 10; ++i) &#123; if (a[i]) cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; a[i] &lt;&lt; endl; &#125; return 0;&#125; 1022 D进制的A+B原题链接 分析：模拟进制转换的过程，首先如果t是0那么直接输出，否则当t != 0时，将每一次t % d的结果保存在ans数组里，然后t /= d，然后逆序输出ans数组即可；JAVA的话用Integer.toString(a,b)即可，将 int 转换为 String，以 b 为进制。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int ans[1005];int main() &#123; int a, b, d, t = 0; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; t = a + b; if (t == 0) &#123; cout &lt;&lt; 0; return 0; &#125; int cnt = 0; while (t != 0) &#123; ans[cnt++] = t % d; t /= d; &#125; for (int i = cnt - 1; i &gt;= 0; --i) cout &lt;&lt; ans[i]; return 0;&#125; 12345678910111213import java.io.BufferedInputStream;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(new BufferedInputStream(System.in)); int a = cin.nextInt(); int b = cin.nextInt(); int c = cin.nextInt(); String str = Integer.toString(a + b, c); System.out.println(str); &#125;&#125; 1023 组个最小数原题链接 分析：简单贪心，先输出一个最小的数字，并将这个数字用t保存，0除外，然后在输出a[0]个0，以及t数字剩下的个数，以及t后面的所有数字即可。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int a[10];int main() &#123; int t = 0; for (int i = 0; i &lt; 10; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt; 10; ++i) &#123; if (a[i] != 0) &#123; cout &lt;&lt; i; t = i; break; &#125; &#125; for (int i = 0; i &lt; a[0]; ++i) cout &lt;&lt; 0; for (int i = 0; i &lt; a[t] - 1; ++i) cout &lt;&lt; t; for (int i = t + 1; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; a[i]; ++j) cout &lt;&lt; i; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT 1054 求平均值]]></title>
    <url>%2F2019%2F07%2F23%2FPAT-1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。 输入格式：输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。 输出格式：对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。 输入样例 1：75 -3.2 aaa 9999 2.3.4 7.123 2.35 输出样例 1：ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38 输入样例 2：2aaa -9999 输出样例 2：ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined 记录一下：sscanf() – 从一个字符串中读进与指定格式相符的数据即把字符数组a中的内容以”%lf”的格式写道temp中，从左至右sprintf() – 字符串格式化命令，主要功能是把格式化的数据写入某个字符串中。即把temp以”%.2lf”的形式写到b字符数组中，从右至左 思路：可以用JAVA异常处理比较方便，c++的话就直接判断 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;// sscanf() – 从一个字符串中读进与指定格式相符的数据,//把字符数组a中的内容以"%lf"的格式写道temp中，从左至右// sprintf() – 字符串格式化命令，主要功能是把格式化的数据写入某个字符串中。//把temp以"%.2lf"的形式写到b字符数组中，从右至左int main() &#123; int n, cnt = 0; char a[50], b[50]; double temp, sum = 0.0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; scanf("%s", a); sscanf(a, "%lf", &amp;temp); sprintf(b, "%.2f", temp); int ok = 0; for (int j = 0; j &lt; strlen(a); j++) &#123; if (a[j] != b[j]) &#123; ok = 1; break; &#125; &#125; if (ok || temp &lt; -1000 || temp &gt; 1000) &#123; printf("ERROR: %s is not a legal number\n", a); &#125; else &#123; sum += temp; cnt++; &#125; &#125; if (cnt == 1) &#123; printf("The average of 1 number is %.2f", sum); &#125; else if (cnt &gt; 1) &#123; printf("The average of %d numbers is %.2f", cnt, sum * 1.0 / cnt); &#125; else &#123; printf("The average of 0 numbers is Undefined"); &#125; system("pause");&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner; public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int cnt = 0; double y = 0; for (int i = 0; i &lt; n; i++) &#123; double x = 0; String s = null; try &#123; s = in.next(); x = Double.parseDouble(s); double temp = Double.parseDouble(String.format("%.2f", x)); if (x &gt; 1000 || x &lt; -1000 || Math.abs(temp - x) &gt;= 0.001) &#123; throw new NumberFormatException(); &#125; cnt++; y += x; &#125; catch (NumberFormatException e) &#123; System.out.println("ERROR: " + s + " is not a legal number"); &#125; &#125; in.close(); if (cnt == 0) &#123; System.out.println("The average of 0 numbers is Undefined"); &#125; else if (cnt == 1) &#123; System.out.printf("The average of 1 number is %.2f", y); &#125; else &#123; System.out.printf("The average of %d numbers is %.2f", cnt, y / cnt); &#125; &#125; &#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT 1052 卖个萌]]></title>
    <url>%2F2019%2F07%2F23%2FPAT-1052-%E5%8D%96%E4%B8%AA%E8%90%8C%2F</url>
    <content type="text"><![CDATA[题目萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的： [左手] ([左眼][口][右眼]) [右手] 现给出可选用的符号集合，请你按用户的要求输出表情。 输入格式：输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 [ ]内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。 之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。 输出格式：对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @/@。 输入样例：[╮][╭][o][][/] [&lt;][&gt;] [╯][╰][^][-][=][&gt;][&lt;][@][⊙][Д][▽][_][ε][^] …41 1 2 2 26 8 1 5 53 3 4 3 32 10 3 9 3 输出样例：╮(╯▽╰)╭&lt;(@Д=)/~o(^ε^)oAre you kidding me? @/@ 思路：因为不知道一行有多少个表情，所以用一个string类型的不定长二维数组vector存储表情包，以及可以调用v.size()顺便解决不知道一行有多少个表情的问题不定长数组共三行，分别对应输入用例的三行，只不过在存储如数组之前把它们的方括号去掉在存储，这里可以用string的substr方法实现然后根据输入的数字序号输出对应的表情注意：1.“Are you kidding me? @/@”的’\’是转义字符，想要输出’\’就要用’\’表示，‘%’也是同理，要想输出需要‘%%’才可以2.第一个测试点里面包含了空格，所以用cin会失败的，要用getline才能读入一行字符串 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;vector&lt;string&gt; &gt; v;//string v[10][10]; for (int i = 0; i &lt; 3; ++i) &#123; string s; getline(cin, s); vector&lt;string&gt; v1;//string v1[10]; for (int j = 0, k = 0; j &lt; s.length(); ++j) &#123; if (s[j] == '[') &#123; while (k++ &lt; s.length()) &#123; if (s[k] == ']') &#123; v1.push_back(s.substr(j + 1, k - j - 1)); break; &#125; &#125; &#125; &#125; v.push_back(v1); &#125; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; int a, b, c, d, e; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; if (a &gt; v[0].size() || b &gt; v[1].size() || c &gt; v[2].size() || d &gt; v[1].size() || e &gt; v[0].size() || a &lt; 1 || b &lt; 1 || c &lt; 1 || d &lt; 1 || e &lt; 1) &#123; cout &lt;&lt; "Are you kidding me? @\\/@" &lt;&lt; endl; continue; &#125; cout &lt;&lt; v[0][a - 1] &lt;&lt; "(" &lt;&lt; v[1][b - 1] &lt;&lt; v[2][c - 1] &lt;&lt; v[1][d - 1] &lt;&lt; ")" &lt;&lt; v[0][e - 1] &lt;&lt; endl; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1050 螺旋矩阵]]></title>
    <url>%2F2019%2F07%2F23%2FPAT-1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。 输入格式：输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 10^4，相邻数字以空格分隔。 输出格式：输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 输入样例：12 37 76 20 98 76 42 53 95 60 81 58 93 输出样例：98 95 9342 37 8153 20 7658 60 76 思路：这题单纯只是想记录下找出N的两个差值最小的约数，即sqrt（N）前后的两个数,大的为m,小的为n即可，螺旋矩阵就直接按右、下、左、上模拟即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;int cmp(int x, int y) &#123; return x &gt; y; &#125;int main() &#123; int N, c, r; cin &gt;&gt; N; for (r = sqrt(N); r &gt;= 1; r--) &#123; if (N % r == 0) &#123; c = N / r; break; &#125; &#125; int a[N + 5], b[c + 5][r + 5]; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i = 0; i &lt; N; ++i) cin &gt;&gt; a[i]; sort(a, a + N, cmp); b[0][0] = a[0]; int t = 0, x = 0, y = 0; while (t &lt; r * c) &#123; while (y + 1 &lt; r &amp;&amp; !b[x][y + 1]) &#123; y++, t++; b[x][y] = a[t]; &#125; while (x + 1 &lt; c &amp;&amp; !b[x + 1][y]) &#123; x++, t++; b[x][y] = a[t]; &#125; while (y - 1 &gt;= 0 &amp;&amp; !b[x][y - 1]) &#123; y--, t++; b[x][y] = a[t]; &#125; while (x - 1 &gt;= 0 &amp;&amp; !b[x - 1][y]) &#123; x--, t++; b[x][y] = a[t]; &#125; &#125; for (int i = 0; i &lt; c; ++i) &#123; for (int j = 0; j &lt; r; ++j) &#123; if (j == r - 1) printf("%d\n", b[i][j]); else printf("%d ", b[i][j]); &#125; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1049 数列的片段和]]></title>
    <url>%2F2019%2F07%2F23%2FPAT-1049-%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。 给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。 输入格式：输入第一行给出一个不超过 10^5的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。 输出格式：在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。 输入样例：4 0.1 0.2 0.3 0.4 输出样例：5.00 思路：第一次直接模拟，结果直接超时，后来发现可以推公式，即先算出右边包括其本身出现的次数，是n-i，那么他左边的次数就是i+1，比如3之前有1、2，那么2 * 右边的次数 * a[i] 就是ans，因为对于1可以和右边的3，（3，4）组合即，123，1234，2也可以组成23，234，所以排列组合得ans = 左边的个数 * 右边的个数 * a[i]; 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;double a[100005];int main() &#123; int n; scanf("%d", &amp;n); double sum = 0.00; for (int i = 0; i &lt; n; ++i) &#123; scanf("%lf", &amp;a[i]); sum += (i + 1) * a[i] * (n - i); &#125; //先算出右边包括其本身出现的次数，是n-i，那么他左边的次数就是i+1，比如3之前有1、2，那么2*右边的次数*a[i]就是大小， //因为对于1可以和右边的3，（3，4）组合即，123，1234，2也可以组成23，234， //所以排列组合得ans=左边的个数*右边的个数*a[i]; // for (int i = 0; i &lt; n; ++i) &#123; //每次选一个数 // for (int j = 0; j &lt; n - i; ++j) &#123; //一个数、两个数、三个数... // for (int k = i; k &lt; n - j; ++k) &#123; //累加 // sum += a[k]; // &#125; // &#125; // &#125;TLE printf("%.2lf\n", sum); system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 学习笔记]]></title>
    <url>%2F2019%2F07%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、概述 三网：电信网络，有线电视网络，计算机网络 Internet：因特网 internet：互联网/互连网 在网络核心部分起特殊作用的是路由器，路由器转发收到的分组就是实现分组交换。 两类通信方式： 客户-服务器模式（C/S）: 客户是服务的请求方，服务器是服务的提供方 客户程序： 1. 客户程序被用户调用后，在通信时主动向远地服务器发起通信请求服务，因此，客户程序必须知道服务器的地址 2. 不需要特殊的硬件以及复杂的操作系统。 服务器程序： 1. 服务器程序是一种专门用来提供服务的程序，可同时处理多个远地或本地客户的请求。 2.系统启动后一直不断地运行着，被动地等待并接受来自各地用户的请求。因此，服务器程序不需要知道客户程序的地址 对等连接方式（P2P）：表示两个主机在通信时并不区分哪一个是服务请求方还是服务提供方，是对等的连接通信。即既是客户端又是服务端。 点到点：相邻结点之间的通信，中间无中转站 端到端：终端到终端，中间有很多结点 总的来说就是端到端就是由无数的点到点组成和实现的。 试比较三种主要交换技术的优缺点。 1.电路交换：在数据传输之前必须设置一条专用的物理通路，在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。优点是快速、可靠、保序、适用于连续传送大量数据。缺点就是传送计算机数据时线路的传输效率往往很低。 2.报文交换：不需要预先分配传输带宽，动态逐段利用传输带宽对突发式数据通信效率高，通信迅速。缺点是存储转发造成的时延较长。 3.分组交换：把报文分割成固定长度的分组，采用“存储转发”原理传输，经路由器储存转发，到达目标结点后重新组装成报文并且不需要预先分配传输带宽，优点是高效、灵活、迅速、可靠，缺点是存储转发会造成时延，分组必须携带的首部造成一定的开销。 例. 试在下列条件下比较电路交换和分组交换。要传送的报文共x（bit）。从源点到终点共经过k段链路，每段链路的传播时延为d（s），数据率为b(b/s)。在电路交换时电路的建立时间为s(s)。在分组交换时分组长度为p(bit)，且各结点的排队等待时间可忽略不计。问在怎样的条件下，分组交换的时延比电路交换的要小？（提示：画一下草图观察k段链路共有几个结点。） 答：线路交换时延：kd+x/b+s, 分组交换时延：kd+(x/p)(p/b)+ (k-1)(p/b)，其中(k-1)(p/b)表示K段传输中，有(k-1)次的储存转发延迟，当s&gt;(k-1)(p/b)时，电路交换的时延比分组交换的时延大，当x&gt;&gt;p,相反。 主机是为用户进行信息处理的，路由器则是对分组进行存储转发，即进行分组交换 早期的面向终端的计算机网络是以单个主机为中心的星形网分组交换网则是以网络为中心，主机都处在网络的外围 按作用范围：WAN(广域网），MAN（城域网），LAN（局域网），PAN（个人区域与网）； 计算机网络的性能指标：速率，带宽，吞吐量，时延，时延带宽积，往返时间，利用率对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率，提高数据的发送速率只是减小了数据的发送时延D = D0/(1-U)，U为利用率，D为时延，因此利用率不是越高越好。减少方法：增大线路的带宽。总时延 = 发送时延 + 传送时延 + 处理时延 + 排队时延 计算机网络的非性能指标：费用，质量，标准化，可靠性，可扩展性和可升级性，易于管理和维护 协议分层的好处：1.各层之间是相互独立的；2.灵活性好；3.结构上可分隔开；4.易于实现和维护；5.能促进标准化工作 ATM:异步传输模式 组成网络协议的三要素是语义、语法、定时 五层体系结构的功能： 1.物理层：物理层的功能就是透明地传送比特流。 2.数据链路层：数据链路层的功能是在两个相邻结点间的线路上无差错地传送以帧为单位的数据。//传输单位：帧，最短为64字节 3.网络层：网络层的功能就是要选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。 4.运输层：运输层的功能是向上一层的进行通信的两个进程之间提供一个可靠的端到端服务。//传输单位：报文段 5.应用层：应用层的功能直接为用户的应用进程提供服务。//传输单位：报文]]></content>
      <categories>
        <category>专业课相关</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数值分析 学习笔记]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Chapter 1 误差误差：模型误差，观测误差，截断误差(方法误差)，舍入误差//前两种不可避免总误差＝截断误差＋舍入误差\由于相对误差可以很大，因此“应避免两个相近的数作减法”，以防止有效数字丢失。//所以遇到分式减法需要优化就通分，例1.4应避免接近于零的数作分母，并避免大的数作乘法.]]></content>
      <categories>
        <category>专业课相关</category>
      </categories>
      <tags>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓入门 学习笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%AE%89%E5%8D%93%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JDK + android studio安装JDK和环境变量的配置；最新的android studio要求至少JDK1.8以上去官网下载最新版本的android studio；SDK可以下载android studio之后去settings里下载； SDK Software Development Kit, 软件开发工具包 NDK Native Development Kit, 安卓原生开发工具包 hello world工程目录结构 src JAVA源代码目录，放置JAVA的源代码R.java 定义与res文件下资源相对应的iddrawable 图像资源values 值资源（字符串资源、风格资源等）layout 布局资源AndroidManifest.xml 核心配置文件，界面、服务等组件配置，每生成一个activity都要在这里注册 hello world详解 创建工程，生成MainActivity类，继承自Activity类onCreate方法：设置内容视图，在当前页面被创建时展现布局setContentView：展示布局（就是把xml布局文件部署到当前页面）\ 12345678import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.appcompat.widget.LinearLayoutCompat xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/androidx.appcompat.widget.LinearLayoutCompat&gt; Activity（可视化交互界面） layout中定义的布局都会在Activity中进行显示操作系统→Manifest→Activity→setContentView调用xml布局通过Activity.java动态修改layout控件findViewById: 通过R.java中定义的id找到view View 通过获取View来控制对象给View添加一个id,view = findViewById(R.id.ID);调用.set方法来修改对象的属性： view.setText(“hello KYZ”); 使用监听器进行交互实现监听器接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import androidx.appcompat.app.ActionBar;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.net.Uri;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.EditText;import android.widget.ImageView;import android.widget.ProgressBar;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private SharedPreferences sharedPreferences; private ImageView imageView; private ProgressBar progressBar; private ActionBar actionBar; private CheckBox remember; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); userid = (EditText) findViewById(R.id.edit_text1); password = (EditText) findViewById(R.id.edit_text2); imageView = (ImageView) findViewById(R.id.image_view); actionBar = getSupportActionBar(); if (actionBar != null) actionBar.hide(); Button pedit = (Button) findViewById(R.id.edit); pedit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("https://im.qq.com/")); startActivity(intent); &#125;//进网址 &#125;); Button pback = (Button) findViewById(R.id.back); pback.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this, "You clicked the back button", Toast.LENGTH_SHORT).show(); &#125;//当点击按钮出现Toast弹窗 &#125;); Button register = (Button) findViewById(R.id.id1); register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("https://im.qq.com/")); startActivity(intent); &#125; &#125;); Button login = (Button) findViewById(R.id.id2); login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (userid.getText().toString().equals("KYZ") &amp;&amp; password.getText().toString().equals("******")) &#123; Intent intent = new Intent(MainActivity.this, menuTest.class); startActivity(intent); &#125; else &#123; Toast.makeText(MainActivity.this, "您的账号或密码错误", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); getSharePreferece(); remember = (CheckBox) findViewById(R.id.remember_pass); remember.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; userin = userid.getText().toString(); passwo = password.getText().toString(); setSharePreferece(); &#125; &#125;); &#125; layout布局 Linear Layout和Relative Layout，线性布局和相对布局xml布局文件、Java代码oriandroid:orientation=”vertical” 垂直分布 horizontal 水平分布gravity 当前内容与控件对齐方式layout_gravity 与父控件的对齐方式match_parent 填充父控件wrap_content 适应内容padding 内容与控件边界的距离margin 控件相对于控件的距离weight ：注意设置宽度/高度为0dppx：像素dp：设备独立像素，给控件设置宽高sp：字体会跟随系统设置变化，给内容设置大小 UI基础TextView属性 id “@id/ID”，引用已有ID， “@+id/ID”，创建新IDbackground “#00ffff” “@color/COLOR”引用已有COLORbackground “@drawable/picture” （JPG小，但不可显示透明色，PNG大）string 引用stringtextSize:”15sp” textColor:”@color/COLOR”autoLink:” web / email / phone / map “ 链接drawableLeft 给控件周围添加图片singleLine 单行显示内容ellipsize 剩余内容如何显示（省略号，跑马灯等）textStyle 字体风格，正常、粗体、斜体typeface 字体类型，（美工相关） 匿名内部类相较于成员内部类而言，直接在对button进行setOnClickListener对象的时候new一个匿名对象，然后重写Onclick即可。 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);//装载xml布局 bt = findViewById(R.id.button2);//获取button对象 bt.setOnClickListener( new View.OnClickListener() &#123;//匿名内部类 @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this,"hello KYZ!",Toast.LENGTH_LONG).show(); //LENGTH_LONG弹窗时间长一些，LENGTH_SHORT时间段短些 &#125; &#125;);&#125; EditText inputType 设置输入文本类型 textPassword(密码)text 默认内容hint 提示内容maxLength 最长长度ImageView ImageButton（带背景图的可视控件）src 导入前景图片scaleType 填充类型 center / centercrop / centerinside等CheckBox 多选按钮CheckBox监听器内部类 保存密码12345678910111213141516171819private final String filename = "login.xml";private String userin, passwo;private EditText userid, password;public void setSharePreferece() &#123; sharedPreferences = getSharedPreferences(filename, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putString("账号", userin); editor.putString("密码", passwo); editor.commit();&#125;public void getSharePreferece() &#123; sharedPreferences = getSharedPreferences(filename, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); userin = sharedPreferences.getString("账号", ""); userid.setText(userin); passwo = sharedPreferences.getString("密码", ""); password.setText(passwo);&#125;]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1308 比赛]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1308-%E6%AF%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[题目描述有n个人要进行比赛，比赛规则如下：假设每轮比赛的人是m，取最大的k，k=2t且k≤m。这k个人每2人举行一场比赛，胜利者进入一下轮，失败者被淘汰。余下的m-k个人，不进行比赛，直接进入下一轮直到决出冠军，比赛结束。比如有5个人参加比赛，第一轮举办2场，剩余3人进入第二轮，第二轮1场，剩余2人进入第三轮，第三轮举办1场决出冠军，所以一共要办4场比赛。 请问一共要举行几轮多少场比赛？ 输入第一行是一个整数K，表示样例的个数。 以后每行一个样例，为n(1≤n≤1000000000) 输出每行输出两个整数，轮数和比赛场数，中间用一个空格隔开。 样例输入2 1 5 样例输出0 0 3 4 思路：直接按题意模拟即可 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; ll n; scanf("%I64d", &amp;n); ll lun = 0, chang = 0; while (n &gt; 1) &#123; ll k = 1; while (k &lt;= n) &#123; //求k if (k * 2 &gt; n) break; k *= 2; &#125; n -= k; k /= 2; //场次 chang += k; lun++; n += k; &#125; printf("%I64d %I64d\n", lun, chang); &#125; system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1296 GCD]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1296-GCD%2F</url>
    <content type="text"><![CDATA[题目描述a和b的最大公约数(Greatest Common Divisor)是最大的d，d能整除a和b。如果gcd(a,b)=1，我们就称a和b是互素的。 给一个区间[a,b]，求与6互素的数的个数。比如区间[1,10],与6互素的数为1,5,7,所以一共是3个。 输入第一行是一个整数K(K≤10,000)，表示样例的个数。每个样例占一行,为区间[a,b],(1≤a≤b≤1,000,000,000) 输出每行输出一个样例的结果 样例输入21 101 1000000000 样例输出3333333333 思路：容斥，与6互素就不会有和6一样的因子2,3，所以[l,r]区间的数减去2和3的倍数再加上6的倍数(计算2和3的倍数时多减了一次)即为答案，另外对于大数判断倍数遍历判断是肯定会超时的，有个思路就是就是 1 到 n 有多少个是 m 倍数，个数为 n/m。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a, b;int main() &#123; int k; scanf("%d", &amp;k); while (k--) &#123; scanf("%lld%lld", &amp;a, &amp;b); ll l = (b * 1.0 / 2) - (a - 1) * 1.0 / 2; ll r = (b * 1.0) / 3 - (a - 1) * 1.0 / 3; ll lr = b - a + 1; ll sum = (b * 1.0) / 6 - (a - 1) * 1.0 / 6; sum = lr - l - r + sum; printf("%lld\n", sum); &#125;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1294 Enquiry]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1294-Enquiry%2F</url>
    <content type="text"><![CDATA[题目描述男女同学排成一列，你想知道第i个到第j个同学之间，男女相邻排列的出现次数。 输入第一行是一个整数K，表示样例的个数。每个样例的第一行是一个字符串s，其长度len不超过10000，只含字符M和F，M表示男生，F表示女生。每个样例的第二行是一个整数n(1≤n≤1000)，表示查询的次数。以后的N行,每行两个整数i,j(1≤i&lt;j≤len)，表示查询的区间。 输出每个样例的每次查询输出一个整数。 样例输入2MMMMM31 21 31 5MFMFM31 52 33 5 样例输出000412 思路：维护一个前缀和即可，pre[i]表示1…i有多少男女相邻的个数 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, pre[10005];//维护一个前缀和void presum(string str) &#123; memset(pre, 0, sizeof(pre)); pre[0] = 0; for (int i = 1; i &lt; str.length(); ++i) &#123; if (str[i - 1] != str[i]) pre[i] = 1; pre[i] = pre[i] + pre[i - 1]; &#125;&#125;int main() &#123; int k, a, b; scanf("%d", &amp;k); while (k--) &#123; string s; cin &gt;&gt; s; presum(s); scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", pre[b - 1] - pre[a - 1]); &#125; &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1291 Buying Gifts]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1291-Buying-Gifts%2F</url>
    <content type="text"><![CDATA[题目描述快到年末了，Boss Liu准备在年会上发些礼物，由于不想礼物的价格区别太大，Boss Liu希望最好的礼物与最差的礼物价格相差越小越好。 当然，如果存在相同的选择，Boss Liu希望花的钱越少越好。Boss Liu把这个买礼物的任务给你，你决定写个程序来帮助自己计算一下。 输入第一行是一个整数K，表示样例的个数。每个样例的第一行是一个整数n,m(1≤m≤n≤1000)，分别表示可购买的礼物的个数和实际需要购买的个数。每个样例的第二行是n个整数xi,i=1,2,⋯,n(1≤xi≤100)，表示n个礼物的价格。 输出每个样例输出两个整数，分别表示最小的价差以及总的花费，中间用一个空格隔开。 样例输入25 310 5 9 7 25 110 5 9 7 2\ 样例输出3 260 2 线索第一个样例，购买10,9,7的礼物的差值最小为3，总花费是26。第二个样例，因为只买一样所以差值都是0，最小花费是2。 思路：将价格升序排序后以长度m尺取找出最小价格差即可，由于排好序所以总和肯定取之前的更小 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int x[1005], n, m; //礼物的价格、可购买的个数、实际需要购买的次数int sum(int a) &#123; int ans = 0; for (int i = a; i &lt; m + a; ++i) ans += x[i]; return ans;&#125;int main() &#123; int k; scanf("%d", &amp;k); while (k--) &#123; memset(x, 0, sizeof(x)); scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf("%d", &amp;x[i]); sort(x, x + n); int minv = 100005, spend = 0; for (int i = 0; i &lt; n; ++i) &#123; if (x[m + i - 1] - x[i] &lt; minv) &#123; minv = x[m + i - 1] - x[i]; spend = sum(i); &#125; else if (x[m + i - 1] - x[i] == minv) &#123; spend = min(sum(i), spend); &#125; if (m + i - 1 == n - 1) break; &#125; printf("%d %d\n", minv, spend); &#125;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>尺取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1243 Bob's Password]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1243-Bob-s-Password%2F</url>
    <content type="text"><![CDATA[题目描述Bob最新购入一款安卓手机，他发现安卓手机密码使用的是画线方式。一共有9个点，我们按行列顺序依次为1~9。密码要求在点和点之间连线不能有还未曾经过的点。比如说：从1出发，可以到2，4，5，6，7，8，但是不能到达3，7，9。但是如果从2出发，先到1，这时因为2已经经过了，所以此时可以到达3。现在给你一个密码，请问它是否符合密码的这个要求？ 输入第一行是一个整数T(1≤T≤10000)，表示样例的个数。一个样例占一行，是一个最短为4位，最长9位，只含1-9的字符串，且1-9最多只有1个。 输出每个样例输出一行，如果合法输出“Yes”，否则输出“No”。 样例输入316852213132 样例输出YesYesNo 思路：首先用一个mp数组存储每个点到其它各点的状态，比如对1来说，1-&gt;1是自身不可访问，标记为-1，1-&gt;2可以访问，标记为0，1-&gt;3需要先经过2这个点，标记为2，即2这个点被访问，我们可以用访问数组进行标记，之后根据样例判断即可。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int mp[10][10] = &#123; &#123;-5, -5, -5, -5, -5, -5, -5, -5, -5, -5&#125;, &#123;-5, -1, 0, 2, 0, 0, 0, 4, 0, 5&#125;, &#123;-5, 0, -1, 0, 0, 0, 0, 0, 5, 0&#125;, &#123;-5, 2, 0, -1, 0, 0, 0, 5, 0, 6&#125;, &#123;-5, 0, 0, 0, -1, 0, 5, 0, 0, 0&#125;, &#123;-5, 0, 0, 0, 0, -1, 0, 0, 0, 0&#125;, &#123;-5, 0, 0, 0, 5, 0, -1, 0, 0, 0&#125;, &#123;-5, 4, 0, 5, 0, 0, 0, -1, 0, 8&#125;, &#123;-5, 0, 5, 0, 0, 0, 0, 0, -1, 0&#125;, &#123;-5, 5, 0, 6, 0, 0, 0, 8, 0, -1&#125;&#125;;int vis[10];int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; memset(vis, 0, sizeof(vis)); string s; bool ok = true; cin &gt;&gt; s; vis[s[0] - '0'] = 1; for (int i = 1; i &lt; s.length(); ++i) &#123; if (mp[s[i - 1] - '0'][s[i] - '0'] == 0 ||vis[mp[s[i - 1] - '0'][s[i] - '0']]) &#123; vis[s[i] - '0'] = 1; ok = true; &#125; else &#123; ok = false; break; &#125; &#125; if (ok) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; // system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT 1039 到底买不买]]></title>
    <url>%2F2019%2F07%2F19%2FPAT-1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[题目小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。 为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 输入格式：每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 输出格式：如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。 输入样例 1：ppRYYGrrYBR2258YrR8RrY 输出样例 1：Yes 8 输入样例 2：ppRYYGrrYB225YrR8RrY 输出样例 2：No 2 思路：用两个数组分别存储摊主的珠串的个数以及小红想做的珠串的个数，我这里是把[0-9]、[a-z]、[A-Z]都转成数字，方便用数组统计，之后判断如果man[i]&gt;shop[i]，那么就是no，缺少的个数是sum += man[i] + shop[i]，反之若是yes，多余的个数就是sum += shop[i] - man[i]。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int shop[65], man[65];int main() &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; bool ok = true; for (int i = 0; i &lt; s1.length(); ++i) &#123; if (s1[i] &lt;= 'z' &amp;&amp; s1[i] &gt;= 'a') shop[s1[i] - 'a' + 10]++; else if (s1[i] &lt;= 'Z' &amp;&amp; s1[i] &gt;= 'A') shop[s1[i] - 'A' + 36]++; else shop[s1[i] - '0']++; &#125; for (int i = 0; i &lt; s2.length(); ++i) &#123; if (s2[i] &lt;= 'z' &amp;&amp; s2[i] &gt;= 'a') man[s2[i] - 'a' + 10]++; else if (s2[i] &lt;= 'Z' &amp;&amp; s2[i] &gt;= 'A') man[s2[i] - 'A' + 36]++; else man[s2[i] - '0']++; &#125; int sum = 0; for (int i = 0; i &lt; 62; ++i) &#123; if (man[i] &gt; shop[i]) ok = false; &#125; if (ok) &#123; for (int i = 0; i &lt; 62; ++i) sum += shop[i] - man[i]; cout &lt;&lt; "Yes " &lt;&lt; sum &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; 62; ++i) &#123; if (shop[i] &lt; man[i]) sum += man[i] - shop[i]; &#125; cout &lt;&lt; "No " &lt;&lt; sum &lt;&lt; endl; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1271 Color]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1271-Color%2F</url>
    <content type="text"><![CDATA[题目Alice在玩一个游戏，她在一个m×n的格子里，随机涂黑k个格子。然后她每次可以把一行或者一列的格子染成红色，但是这一行中不能有黑色的格子。 请问她最多能把多少个格子涂成红色？ 输入第一行是一个整数T(T≤100)，表示样例的个数。 每个样例的第一行是m(1≤m≤100),n(1≤n≤100),k(0≤k≤m×n)。 以后的k行,每行两个整数x(1≤x≤m),y(1≤y≤n)，表示(x,y)为黑色格子。 输出每行输出一个样例的结果。 样例输入13 4 21 13 3 样例输出8 思路：首先根据x y统计有哪几行哪几列有黑色格子，用row和col数组存储，再对二者遍历可得全为红格子的行数以及红格子的列数，用r和c表示，那么我们可以推出公式ans = r * n + c * m - r * c; 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef long long ll;int row[105], col[105];int main() &#123; int T, m, n, k, x, y; scanf("%d", &amp;T); while (T--) &#123; memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); scanf("%d%d%d", &amp;m, &amp;n, &amp;k); while (k--) &#123; scanf("%d%d", &amp;x, &amp;y); row[x - 1] = 1; col[y - 1] = 1; &#125; int r = 0, c = 0; for (int i = 0; i &lt; m; ++i) &#123; if (!row[i]) r++; &#125; for (int i = 0; i &lt; n; ++i) &#123; if (!col[i]) c++; &#125; ll ans = r * n + c * m - r * c; printf("%lld\n", ans); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1262 Fish(优先队列+贪心)]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1262-Fish-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[题目小明很喜欢钓鱼，现在有n个池塘可以钓鱼，第i个池塘首次内能钓到ai条鱼。 第i个池塘如果被钓过k次，那么每次下一次能钓到的鱼的数目为max{0,ai−k×bi}。现在小明能钓m次鱼，请问他最多能钓到多少条鱼？ 输入第一行是一个整数T(1≤T≤100)，表示样例的个数。每个样例的第一行是n(1≤n≤1000),m(1≤m≤100000)；以后的n行，每行是ai(1≤ai≤10000),bi(0≤bi≤10000)。 输出每行输出一个样例的结果。 样例输入23 53 14 21 02 52 11 1 样例输出124 样例解释第一个样例，在第1个池塘钓3次，第2个池塘钓2次，3+2+1+4+2 = 12； 第二个样例，在第1个池塘钓2次，第2个池塘钓1次，2+1+1 = 4。 思路：维护一个优先队列，使价值最高的鱼优先级最高，钓出这种鱼后，从队首弹出这种鱼，改变价值后再压入，这样便能保证每次钓到的鱼都是价值最高的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int a, b, a1, k; //从大到小排列 friend bool operator&lt;(node X, node Y) &#123; return X.a &lt; Y.a; &#125;&#125;;priority_queue&lt;node&gt; pq;// max&#123;0,ai−k×bi&#125;int main() &#123; int T, n, m, a, b; scanf("%d", &amp;T); while (T--) &#123; while (!pq.empty()) pq.pop(); //每次先将队列清空 scanf("%d%d", &amp;n, &amp;m); node nd; while (n--) &#123; scanf("%d%d", &amp;a, &amp;b); nd.a = a; nd.a1 = a; nd.b = b; nd.k = 0; pq.push(nd); &#125; int cnt = 0; while (!pq.empty()) &#123; nd = pq.top(); pq.pop(); if (nd.b != 0) &#123; cnt += nd.a; nd.k++; nd.a = max(0, nd.a1 - nd.k * nd.b); //更新 m--; pq.push(nd); &#125; else &#123; cnt += nd.a * m; //此时数目是当前最多并且不需要更新 m = 0; break; &#125; if (!m) break; &#125; printf("%d\n", cnt); &#125; // system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
