<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[安卓入门学习笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%AE%89%E5%8D%93%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JDK + android studio安装JDK和环境变量的配置；最新的android studio要求至少JDK1.8以上去官网下载最新版本的android studio；SDK可以下载android studio之后去settings里下载； SDK Software Development Kit, 软件开发工具包 NDK Native Development Kit, 安卓原生开发工具包 hello world工程目录结构 src JAVA源代码目录，放置JAVA的源代码R.java 定义与res文件下资源相对应的iddrawable 图像资源values 值资源（字符串资源、风格资源等）layout 布局资源AndroidManifest.xml 核心配置文件，界面、服务等组件配置，每生成一个activity都要在这里注册 hello world详解 创建工程，生成MainActivity类，继承自Activity类onCreate方法：设置内容视图，在当前页面被创建时展现布局setContentView：展示布局（就是把xml布局文件部署到当前页面）\ 12345678import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.appcompat.widget.LinearLayoutCompat xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/androidx.appcompat.widget.LinearLayoutCompat&gt;` Activity（可视化交互界面） layout中定义的布局都会在Activity中进行显示操作系统→Manifest→Activity→setContentView调用xml布局通过Activity.java动态修改layout控件findViewById: 通过R.java中定义的id找到view View 通过获取View来控制对象给View添加一个id,view = findViewById(R.id.ID);调用.set方法来修改对象的属性： view.setText(“hello KYZ”); 使用监听器进行交互实现监听器接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import androidx.appcompat.app.ActionBar;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.net.Uri;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.EditText;import android.widget.ImageView;import android.widget.ProgressBar;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private SharedPreferences sharedPreferences; private ImageView imageView; private ProgressBar progressBar; private ActionBar actionBar; private CheckBox remember; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); userid = (EditText) findViewById(R.id.edit_text1); password = (EditText) findViewById(R.id.edit_text2); imageView = (ImageView) findViewById(R.id.image_view); actionBar = getSupportActionBar(); if (actionBar != null) actionBar.hide(); Button pedit = (Button) findViewById(R.id.edit); pedit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("https://im.qq.com/")); startActivity(intent); &#125;//进网址 &#125;); Button pback = (Button) findViewById(R.id.back); pback.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this, "You clicked the back button", Toast.LENGTH_SHORT).show(); &#125;//当点击按钮出现Toast弹窗 &#125;); Button register = (Button) findViewById(R.id.id1); register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("https://im.qq.com/")); startActivity(intent); &#125; &#125;); Button login = (Button) findViewById(R.id.id2); login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (userid.getText().toString().equals("KYZ") &amp;&amp; password.getText().toString().equals("******")) &#123; Intent intent = new Intent(MainActivity.this, menuTest.class); startActivity(intent); &#125; else &#123; Toast.makeText(MainActivity.this, "您的账号或密码错误", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); getSharePreferece(); remember = (CheckBox) findViewById(R.id.remember_pass); remember.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; userin = userid.getText().toString(); passwo = password.getText().toString(); setSharePreferece(); &#125; &#125;); &#125; layout布局 Linear Layout和Relative Layout，线性布局和相对布局xml布局文件、Java代码oriandroid:orientation=”vertical” 垂直分布 horizontal 水平分布gravity 当前内容与控件对齐方式layout_gravity 与父控件的对齐方式match_parent 填充父控件wrap_content 适应内容padding 内容与控件边界的距离margin 控件相对于控件的距离weight ：注意设置宽度/高度为0dppx：像素dp：设备独立像素，给控件设置宽高sp：字体会跟随系统设置变化，给内容设置大小 UI基础TextView属性 id “@id/ID”，引用已有ID， “@+id/ID”，创建新IDbackground “#00ffff” “@color/COLOR”引用已有COLORbackground “@drawable/picture” （JPG小，但不可显示透明色，PNG大）string 引用stringtextSize:”15sp” textColor:”@color/COLOR”autoLink:” web / email / phone / map “ 链接drawableLeft 给控件周围添加图片singleLine 单行显示内容ellipsize 剩余内容如何显示（省略号，跑马灯等）textStyle 字体风格，正常、粗体、斜体typeface 字体类型，（美工相关） 匿名内部类相较于成员内部类而言，直接在对button进行setOnClickListener对象的时候new一个匿名对象，然后重写Onclick即可。 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);//装载xml布局 bt = findViewById(R.id.button2);//获取button对象 bt.setOnClickListener( new View.OnClickListener() &#123;//匿名内部类 @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this,"hello KYZ!",Toast.LENGTH_LONG).show(); //LENGTH_LONG弹窗时间长一些，LENGTH_SHORT时间段短些 &#125; &#125;);&#125; EditText inputType 设置输入文本类型 textPassword(密码)text 默认内容hint 提示内容maxLength 最长长度ImageView ImageButton（带背景图的可视控件）src 导入前景图片scaleType 填充类型 center / centercrop / centerinside等CheckBox 多选按钮CheckBox监听器内部类 保存密码12345678910111213141516171819private final String filename = "login.xml";private String userin, passwo;private EditText userid, password;public void setSharePreferece() &#123; sharedPreferences = getSharedPreferences(filename, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putString("账号", userin); editor.putString("密码", passwo); editor.commit();&#125;public void getSharePreferece() &#123; sharedPreferences = getSharedPreferences(filename, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); userin = sharedPreferences.getString("账号", ""); userid.setText(userin); passwo = sharedPreferences.getString("密码", ""); password.setText(passwo);&#125;]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1308 比赛]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1308-%E6%AF%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[题目描述有n个人要进行比赛，比赛规则如下：假设每轮比赛的人是m，取最大的k，k=2t且k≤m。这k个人每2人举行一场比赛，胜利者进入一下轮，失败者被淘汰。余下的m-k个人，不进行比赛，直接进入下一轮直到决出冠军，比赛结束。比如有5个人参加比赛，第一轮举办2场，剩余3人进入第二轮，第二轮1场，剩余2人进入第三轮，第三轮举办1场决出冠军，所以一共要办4场比赛。 请问一共要举行几轮多少场比赛？ 输入第一行是一个整数K，表示样例的个数。 以后每行一个样例，为n(1≤n≤1000000000) 输出每行输出两个整数，轮数和比赛场数，中间用一个空格隔开。 样例输入2 1 5 样例输出0 0 3 4 思路：直接按题意模拟即可 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; ll n; scanf("%I64d", &amp;n); ll lun = 0, chang = 0; while (n &gt; 1) &#123; ll k = 1; while (k &lt;= n) &#123; //求k if (k * 2 &gt; n) break; k *= 2; &#125; n -= k; k /= 2; //场次 chang += k; lun++; n += k; &#125; printf("%I64d %I64d\n", lun, chang); &#125; system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1296 GCD]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1296-GCD%2F</url>
    <content type="text"><![CDATA[题目描述a和b的最大公约数(Greatest Common Divisor)是最大的d，d能整除a和b。如果gcd(a,b)=1，我们就称a和b是互素的。 给一个区间[a,b]，求与6互素的数的个数。比如区间[1,10],与6互素的数为1,5,7,所以一共是3个。 输入第一行是一个整数K(K≤10,000)，表示样例的个数。每个样例占一行,为区间[a,b],(1≤a≤b≤1,000,000,000) 输出每行输出一个样例的结果 样例输入21 101 1000000000 样例输出3333333333 思路：容斥，与6互素就不会有和6一样的因子2,3，所以[l,r]区间的数减去2和3的倍数再加上6的倍数(计算2和3的倍数时多减了一次)即为答案，另外对于大数判断倍数遍历判断是肯定会超时的，有个思路就是就是 1 到 n 有多少个是 m 倍数，个数为 n/m。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a, b;int main() &#123; int k; scanf("%d", &amp;k); while (k--) &#123; scanf("%lld%lld", &amp;a, &amp;b); ll l = (b * 1.0 / 2) - (a - 1) * 1.0 / 2; ll r = (b * 1.0) / 3 - (a - 1) * 1.0 / 3; ll lr = b - a + 1; ll sum = (b * 1.0) / 6 - (a - 1) * 1.0 / 6; sum = lr - l - r + sum; printf("%lld\n", sum); &#125;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1294 Enquiry]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1294-Enquiry%2F</url>
    <content type="text"><![CDATA[题目描述男女同学排成一列，你想知道第i个到第j个同学之间，男女相邻排列的出现次数。 输入第一行是一个整数K，表示样例的个数。每个样例的第一行是一个字符串s，其长度len不超过10000，只含字符M和F，M表示男生，F表示女生。每个样例的第二行是一个整数n(1≤n≤1000)，表示查询的次数。以后的N行,每行两个整数i,j(1≤i&lt;j≤len)，表示查询的区间。 输出每个样例的每次查询输出一个整数。 样例输入2MMMMM31 21 31 5MFMFM31 52 33 5 样例输出000412 思路：维护一个前缀和即可，pre[i]表示1…i有多少男女相邻的个数 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, pre[10005];//维护一个前缀和void presum(string str) &#123; memset(pre, 0, sizeof(pre)); pre[0] = 0; for (int i = 1; i &lt; str.length(); ++i) &#123; if (str[i - 1] != str[i]) pre[i] = 1; pre[i] = pre[i] + pre[i - 1]; &#125;&#125;int main() &#123; int k, a, b; scanf("%d", &amp;k); while (k--) &#123; string s; cin &gt;&gt; s; presum(s); scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", pre[b - 1] - pre[a - 1]); &#125; &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1291 Buying Gifts]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1291-Buying-Gifts%2F</url>
    <content type="text"><![CDATA[题目描述快到年末了，Boss Liu准备在年会上发些礼物，由于不想礼物的价格区别太大，Boss Liu希望最好的礼物与最差的礼物价格相差越小越好。 当然，如果存在相同的选择，Boss Liu希望花的钱越少越好。Boss Liu把这个买礼物的任务给你，你决定写个程序来帮助自己计算一下。 输入第一行是一个整数K，表示样例的个数。每个样例的第一行是一个整数n,m(1≤m≤n≤1000)，分别表示可购买的礼物的个数和实际需要购买的个数。每个样例的第二行是n个整数xi,i=1,2,⋯,n(1≤xi≤100)，表示n个礼物的价格。 输出每个样例输出两个整数，分别表示最小的价差以及总的花费，中间用一个空格隔开。 样例输入25 310 5 9 7 25 110 5 9 7 2\ 样例输出3 260 2 线索第一个样例，购买10,9,7的礼物的差值最小为3，总花费是26。第二个样例，因为只买一样所以差值都是0，最小花费是2。 思路：将价格升序排序后以长度m尺取找出最小价格差即可，由于排好序所以总和肯定取之前的更小 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int x[1005], n, m; //礼物的价格、可购买的个数、实际需要购买的次数int sum(int a) &#123; int ans = 0; for (int i = a; i &lt; m + a; ++i) ans += x[i]; return ans;&#125;int main() &#123; int k; scanf("%d", &amp;k); while (k--) &#123; memset(x, 0, sizeof(x)); scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf("%d", &amp;x[i]); sort(x, x + n); int minv = 100005, spend = 0; for (int i = 0; i &lt; n; ++i) &#123; if (x[m + i - 1] - x[i] &lt; minv) &#123; minv = x[m + i - 1] - x[i]; spend = sum(i); &#125; else if (x[m + i - 1] - x[i] == minv) &#123; spend = min(sum(i), spend); &#125; if (m + i - 1 == n - 1) break; &#125; printf("%d %d\n", minv, spend); &#125;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>尺取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1243 Bob's Password]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1243-Bob-s-Password%2F</url>
    <content type="text"><![CDATA[题目描述Bob最新购入一款安卓手机，他发现安卓手机密码使用的是画线方式。一共有9个点，我们按行列顺序依次为1~9。密码要求在点和点之间连线不能有还未曾经过的点。比如说：从1出发，可以到2，4，5，6，7，8，但是不能到达3，7，9。但是如果从2出发，先到1，这时因为2已经经过了，所以此时可以到达3。现在给你一个密码，请问它是否符合密码的这个要求？ 输入第一行是一个整数T(1≤T≤10000)，表示样例的个数。一个样例占一行，是一个最短为4位，最长9位，只含1-9的字符串，且1-9最多只有1个。 输出每个样例输出一行，如果合法输出“Yes”，否则输出“No”。 样例输入316852213132 样例输出YesYesNo 思路：首先用一个mp数组存储每个点到其它各点的状态，比如对1来说，1-&gt;1是自身不可访问，标记为-1，1-&gt;2可以访问，标记为0，1-&gt;3需要先经过2这个点，标记为2，即2这个点被访问，我们可以用访问数组进行标记，之后根据样例判断即可。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int mp[10][10] = &#123; &#123;-5, -5, -5, -5, -5, -5, -5, -5, -5, -5&#125;, &#123;-5, -1, 0, 2, 0, 0, 0, 4, 0, 5&#125;, &#123;-5, 0, -1, 0, 0, 0, 0, 0, 5, 0&#125;, &#123;-5, 2, 0, -1, 0, 0, 0, 5, 0, 6&#125;, &#123;-5, 0, 0, 0, -1, 0, 5, 0, 0, 0&#125;, &#123;-5, 0, 0, 0, 0, -1, 0, 0, 0, 0&#125;, &#123;-5, 0, 0, 0, 5, 0, -1, 0, 0, 0&#125;, &#123;-5, 4, 0, 5, 0, 0, 0, -1, 0, 8&#125;, &#123;-5, 0, 5, 0, 0, 0, 0, 0, -1, 0&#125;, &#123;-5, 5, 0, 6, 0, 0, 0, 8, 0, -1&#125;&#125;;int vis[10];int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; memset(vis, 0, sizeof(vis)); string s; bool ok = true; cin &gt;&gt; s; vis[s[0] - '0'] = 1; for (int i = 1; i &lt; s.length(); ++i) &#123; if (mp[s[i - 1] - '0'][s[i] - '0'] == 0 ||vis[mp[s[i - 1] - '0'][s[i] - '0']]) &#123; vis[s[i] - '0'] = 1; ok = true; &#125; else &#123; ok = false; break; &#125; &#125; if (ok) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; // system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT 1039 到底买不买]]></title>
    <url>%2F2019%2F07%2F19%2FPAT-1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[题目小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。 为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 输入格式：每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 输出格式：如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。 输入样例 1：ppRYYGrrYBR2258YrR8RrY 输出样例 1：Yes 8 输入样例 2：ppRYYGrrYB225YrR8RrY 输出样例 2：No 2 思路：用两个数组分别存储摊主的珠串的个数以及小红想做的珠串的个数，我这里是把[0-9]、[a-z]、[A-Z]都转成数字，方便用数组统计，之后判断如果man[i]&gt;shop[i]，那么就是no，缺少的个数是sum += man[i] + shop[i]，反之若是yes，多余的个数就是sum += shop[i] - man[i]。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int shop[65], man[65];int main() &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; bool ok = true; for (int i = 0; i &lt; s1.length(); ++i) &#123; if (s1[i] &lt;= 'z' &amp;&amp; s1[i] &gt;= 'a') shop[s1[i] - 'a' + 10]++; else if (s1[i] &lt;= 'Z' &amp;&amp; s1[i] &gt;= 'A') shop[s1[i] - 'A' + 36]++; else shop[s1[i] - '0']++; &#125; for (int i = 0; i &lt; s2.length(); ++i) &#123; if (s2[i] &lt;= 'z' &amp;&amp; s2[i] &gt;= 'a') man[s2[i] - 'a' + 10]++; else if (s2[i] &lt;= 'Z' &amp;&amp; s2[i] &gt;= 'A') man[s2[i] - 'A' + 36]++; else man[s2[i] - '0']++; &#125; int sum = 0; for (int i = 0; i &lt; 62; ++i) &#123; if (man[i] &gt; shop[i]) ok = false; &#125; if (ok) &#123; for (int i = 0; i &lt; 62; ++i) sum += shop[i] - man[i]; cout &lt;&lt; "Yes " &lt;&lt; sum &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; 62; ++i) &#123; if (shop[i] &lt; man[i]) sum += man[i] - shop[i]; &#125; cout &lt;&lt; "No " &lt;&lt; sum &lt;&lt; endl; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1271 Color]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1271-Color%2F</url>
    <content type="text"><![CDATA[题目Alice在玩一个游戏，她在一个m×n的格子里，随机涂黑k个格子。然后她每次可以把一行或者一列的格子染成红色，但是这一行中不能有黑色的格子。 请问她最多能把多少个格子涂成红色？ 输入第一行是一个整数T(T≤100)，表示样例的个数。 每个样例的第一行是m(1≤m≤100),n(1≤n≤100),k(0≤k≤m×n)。 以后的k行,每行两个整数x(1≤x≤m),y(1≤y≤n)，表示(x,y)为黑色格子。 输出每行输出一个样例的结果。 样例输入13 4 21 13 3 样例输出8 思路：首先根据x y统计有哪几行哪几列有黑色格子，用row和col数组存储，再对二者遍历可得全为红格子的行数以及红格子的列数，用r和c表示，那么我们可以推出公式ans = r * n + c * m - r * c; 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef long long ll;int row[105], col[105];int main() &#123; int T, m, n, k, x, y; scanf("%d", &amp;T); while (T--) &#123; memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); scanf("%d%d%d", &amp;m, &amp;n, &amp;k); while (k--) &#123; scanf("%d%d", &amp;x, &amp;y); row[x - 1] = 1; col[y - 1] = 1; &#125; int r = 0, c = 0; for (int i = 0; i &lt; m; ++i) &#123; if (!row[i]) r++; &#125; for (int i = 0; i &lt; n; ++i) &#123; if (!col[i]) c++; &#125; ll ans = r * n + c * m - r * c; printf("%lld\n", ans); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1262 Fish(优先队列+贪心)]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1262-Fish-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[题目小明很喜欢钓鱼，现在有n个池塘可以钓鱼，第i个池塘首次内能钓到ai条鱼。 第i个池塘如果被钓过k次，那么每次下一次能钓到的鱼的数目为max{0,ai−k×bi}。现在小明能钓m次鱼，请问他最多能钓到多少条鱼？ 输入第一行是一个整数T(1≤T≤100)，表示样例的个数。每个样例的第一行是n(1≤n≤1000),m(1≤m≤100000)；以后的n行，每行是ai(1≤ai≤10000),bi(0≤bi≤10000)。 输出每行输出一个样例的结果。 样例输入23 53 14 21 02 52 11 1 样例输出124 样例解释第一个样例，在第1个池塘钓3次，第2个池塘钓2次，3+2+1+4+2 = 12； 第二个样例，在第1个池塘钓2次，第2个池塘钓1次，2+1+1 = 4。 思路：维护一个优先队列，使价值最高的鱼优先级最高，钓出这种鱼后，从队首弹出这种鱼，改变价值后再压入，这样便能保证每次钓到的鱼都是价值最高的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int a, b, a1, k; //从大到小排列 friend bool operator&lt;(node X, node Y) &#123; return X.a &lt; Y.a; &#125;&#125;;priority_queue&lt;node&gt; pq;// max&#123;0,ai−k×bi&#125;int main() &#123; int T, n, m, a, b; scanf("%d", &amp;T); while (T--) &#123; while (!pq.empty()) pq.pop(); //每次先将队列清空 scanf("%d%d", &amp;n, &amp;m); node nd; while (n--) &#123; scanf("%d%d", &amp;a, &amp;b); nd.a = a; nd.a1 = a; nd.b = b; nd.k = 0; pq.push(nd); &#125; int cnt = 0; while (!pq.empty()) &#123; nd = pq.top(); pq.pop(); if (nd.b != 0) &#123; cnt += nd.a; nd.k++; nd.a = max(0, nd.a1 - nd.k * nd.b); //更新 m--; pq.push(nd); &#125; else &#123; cnt += nd.a * m; //此时数目是当前最多并且不需要更新 m = 0; break; &#125; if (!m) break; &#125; printf("%d\n", cnt); &#125; // system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
