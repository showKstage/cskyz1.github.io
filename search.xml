<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP_ch01]]></title>
    <url>%2F2019%2F11%2F29%2FTCP-ch01%2F</url>
    <content type="text"><![CDATA[第一章：理解网络编程和套接字本章代码，在TCP-IP-NetworkNote中可以找到，直接点连接可能进不去。 1.1 理解网络编程和套接字1.1.1构建打电话套接字以电话机打电话的方式来理解套接字。 调用 socket 函数（安装电话机）时进行的对话： 问：接电话需要准备什么？ 答：当然是电话机。 有了电话机才能安装电话，于是就要准备一个电话机，下面函数相当于电话机的套接字。 123#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);//成功时返回文件描述符，失败时返回-1 调用 bind 函数（分配电话号码）时进行的对话： 问：请问我的电话号码是多少 答：我的电话号码是123-1234 套接字同样如此。就想给电话机分配电话号码一样，利用以下函数给创建好的套接字分配地址信息（IP地址和端口号）： 123#include &lt;sys/socket.h&gt;int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);//成功时返回0，失败时返回-1 调用 bind 函数给套接字分配地址之后，就基本完成了所有的准备工作。接下来是需要连接电话线并等待来电。 调用 listen 函数（连接电话线）时进行的对话： 问：已架设完电话机后是否只需链接电话线？ 答：对，只需要连接就能接听电话。 一连接电话线，电话机就可以转换为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接受连接状态。 123#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);//成功时返回0，失败时返回-1 连接好电话线以后，如果有人拨打电话就响铃，拿起话筒才能接听电话。 调用 accept 函数（拿起话筒）时进行的对话： 问：电话铃响了，我该怎么办？ 答：接听啊。 123#include &lt;sys/socket.h&gt;int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);//成功时返回文件描述符，失败时返回-1 网络编程中和接受连接请求的套接字创建过程可整理如下： 第一步：调用 socket 函数创建套接字。 第二步：调用 bind 函数分配IP地址和端口号。 第三步：调用 listen 函数转换为可接受请求状态。 第四步：调用 accept 函数受理套接字请求。 1.1.2 编写Hello World套接字程序服务端： 服务器端（server）是能够受理连接请求的程序。下面构建服务端以验证之前提到的函数调用过程，该服务器端收到连接请求后向请求者返回Hello World!答复。除各种函数的调用顺序外，我们还未涉及任何实际编程。因此，阅读代码时请重点关注套接字相关的函数调用过程，不必理解全过程。 服务器端代码请参见：hello_server.c 客户端： 客户端程序只有调用 socket 函数创建套接字 和 调用 connect 函数向服务端发送连接请求这两个步骤，下面给出客户端，需要查看以下两方面的内容： 调用 socket 函数 和 connect 函数 与服务端共同运行以收发字符串数据 客户端代码请参见：hello_client.c 编译： 分别对客户端和服务端程序进行编译： 12gcc hello_server.c -o hservergcc hello_client.c -o hclient 运行： 12./hserver 9190./hclient 127.0.0.1 9190 运行的时候，首先再 9190 端口启动服务，然后 heserver 就会一直等待客户端进行响应，当客户端监听位于本地的 IP 为 127.0.0.1 的地址的9190端口时，客户端就会收到服务端的回应，输出Hello World! 1.2 基于 Linux 的文件操作讨论套接字的过程中突然谈及文件也许有些奇怪。但是对于 Linux 而言，socket 操作与文件操作没有区别，因而有必要详细了解文件。在 Linux 世界里，socket 也被认为是文件的一种，因此在网络数据传输过程中自然可以使用 I/O 的相关函数。Windows 与 Linux 不同，是要区分 socket 和文件的。因此在 Windows 中需要调用特殊的数据传输相关函数。 1.2.1 底层访问和文件描述符分配给标准输入输出及标准错误的文件描述符。 文件描述符 对象 0 标准输入：Standard Input 1 标准输出：Standard Output 2 标准错误：Standard Error 文件和套接字一般经过创建过程才会被分配文件描述符。 文件描述符也被称为「文件句柄」，但是「句柄」主要是 Windows 中的术语。因此，在本书中如果设计 Windows 平台将使用「句柄」，如果是 Linux 将使用「描述符」。 1.2.2 打开文件:123456789#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *path, int flag);/*成功时返回文件描述符，失败时返回-1path : 文件名的字符串地址flag : 文件打开模式信息*/ 文件打开模式如下表： 打开模式 含义 O_CREAT 必要时创建文件 O_TRUNC 删除全部现有数据 O_APPEND 维持现有数据，保存到其后面 O_RDONLY 只读打开 O_WRONLY 只写打开 O_RDWR 读写打开 1.2.3 关闭文件：123456#include &lt;unistd.h&gt;int close(int fd);/*成功时返回 0 ，失败时返回 -1fd : 需要关闭的文件或套接字的文件描述符*/ 若调用此函数同时传递文件描述符参数，则关闭（终止）响应文件。另外需要注意的是，此函数不仅可以关闭文件，还可以关闭套接字。再次证明了「Linux 操作系统不区分文件与套接字」的特点。 1.2.4 将数据写入文件：12345678#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes);/*成功时返回写入的字节数 ，失败时返回 -1fd : 显示数据传输对象的文件描述符buf : 保存要传输数据的缓冲值地址nbytes : 要传输数据的字节数*/ 在此函数的定义中，size_t 是通过 typedef 声明的 unsigned int 类型。对 ssize_t 来说，ssize_t 前面多加的 s 代表 signed ，即 ssize_t 是通过 typedef 声明的 signed int 类型。 创建新文件并保存数据： 代码见：low_open.c 编译运行： 12gcc low_open.c -o lopen./lopen 然后会生成一个data.txt的文件，里面有Let&#39;s go! 1.2.5 读取文件中的数据：与之前的write()函数相对应，read()用来输入（接收）数据。 12345678#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes);/*成功时返回接收的字节数（但遇到文件结尾则返回 0），失败时返回 -1fd : 显示数据接收对象的文件描述符buf : 要保存接收的数据的缓冲地址值。nbytes : 要接收数据的最大字节数*/ 下面示例通过 read() 函数读取 data.txt 中保存的数据。 代码见：low_read.c 编译运行： 12gcc low_read.c -o lread./lread 在上一步的 data.txt 文件与没有删的情况下，会输出： 12file descriptor: 3file data: Let&apos;s go! 关于文件描述符的 I/O 操作到此结束，要明白，这些内容同样适合于套接字。 1.2.6 文件描述符与套接字下面将同时创建文件和套接字，并用整数型态比较返回的文件描述符的值. 代码见：fd_seri.c 编译运行： 12gcc fd_seri.c -o fds./fds 输出结果: 123file descriptor 1: 3file descriptor 2: 15file descriptor 3: 16 1.3 基于 Windows 平台的实现暂略 1.4 基于 Windows 的套接字相关函数及示例暂略 1.5 习题 :heavy_exclamation_mark:以下部分的答案，仅代表我个人观点，可能不是正确答案 套接字在网络编程中的作用是什么？为何称它为套接字？ 答：操作系统会提供「套接字」（socket）的部件，套接字是网络数据传输用的软件设备。因此，「网络编程」也叫「套接字编程」。「套接字」就是用来连接网络的工具。 在服务器端创建套接字以后，会依次调用 listen 函数和 accept 函数。请比较二者作用。 答：调用 listen 函数将套接字转换成可受连接状态（监听），调用 accept 函数受理连接请求。如果在没有连接请求的情况下调用该函数，则不会返回，直到有连接请求为止。 Linux 中，对套接字数据进行 I/O 时可以直接使用文件 I/O 相关函数；而在 Windows 中则不可以。原因为何？ 答：暂略。 创建套接字后一般会给他分配地址，为什么？为了完成地址分配需要调用哪个函数？ 答：套接字被创建之后，只有为其分配了IP地址和端口号后，客户端才能够通过IP地址及端口号与服务器端建立连接，需要调用 bind 函数来完成地址分配。 Linux 中的文件描述符与 Windows 的句柄实际上非常类似。请以套接字为对象说明它们的含义。 答：暂略。 底层 I/O 函数与 ANSI 标准定义的文件 I/O 函数有何区别？ 答：文件 I/O 又称为低级磁盘 I/O，遵循 POSIX 相关标准。任何兼容 POSIX 标准的操作系统上都支持文件I/O。标准 I/O 被称为高级磁盘 I/O，遵循 ANSI C 相关标准。只要开发环境中有标准 I/O 库，标准 I/O 就可以使用。（Linux 中使用的是 GLIBC，它是标准C库的超集。不仅包含 ANSI C 中定义的函数，还包括 POSIX 标准中定义的函数。因此，Linux 下既可以使用标准 I/O，也可以使用文件 I/O）。 参考本书给出的示例low_open.c和low_read.c，分别利用底层文件 I/O 和 ANSI 标准 I/O 编写文件复制程序。可任意指定复制程序的使用方法。 答：暂略。]]></content>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Basic Level) Practice]]></title>
    <url>%2F2019%2F08%2F05%2FPAT-Basic-Level-Practice%2F</url>
    <content type="text"><![CDATA[前言&ensp;&ensp;&ensp;&ensp;下半年会陆续考乙级和甲级，今天刚刷完乙级的所有题目，想着来总结一下，觉着一个一个分开写太麻烦，于是就这篇博客将所有题目放在一起进行总结。 1001 害死人不偿命的(3n+1)猜想原题链接 分析：ans从0开始统计需要的步数，(n &amp; 1)不为0 表示n为奇数，当n为奇数，就令n = 3*n+1；偶数将其砍掉一半，步数ans++，直到n == 1为止，最后输出ans即可 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, ans = 0; cin &gt;&gt; n; while (n != 1) &#123; if (n &amp; 1) &#123; n = (3 * n + 1) / 2; ans++; &#125; else &#123; n /= 2; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 1002 写出这个数原题链接 分析：由于n很大，所以我们用string接收输入，将string的每一位数字累加到sum里面，再将sum转化为string类型的num，对num的每一位输出对应中文拼音 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string str[10] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; for (int i = 0; i &lt; s.length(); i++) sum += (s[i] - '0'); string num = to_string(sum); for (int i = 0; i &lt; num.length(); i++) &#123; if (i != 0) cout &lt;&lt; " "; cout &lt;&lt; str[num[i] - '0']; &#125; return 0;&#125; 1004 成绩排名原题链接 分析：将姓名、学号、成绩用一个结构体存储，然后自定义cmp按照成绩升序排序，然后直接输出最后一个元素和第一个元素的信息即可。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; string name; string id; int mark;&#125;;bool cmp(node x, node y) &#123; return x.mark &lt; y.mark; &#125;int main() &#123; int n; cin &gt;&gt; n; node nd[n + 5]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nd[i].name &gt;&gt; nd[i].id &gt;&gt; nd[i].mark; &#125; sort(nd, nd + n, cmp); cout &lt;&lt; nd[n - 1].name &lt;&lt; " " &lt;&lt; nd[n - 1].id &lt;&lt; endl; cout &lt;&lt; nd[0].name &lt;&lt; " " &lt;&lt; nd[0].id &lt;&lt; endl; return 0;&#125; 1005 继续(3n+1)猜想原题链接 分析：对每个数可能产生的被其覆盖的数全部放入一个set里，然后将a按升序排列，从后往前输出，若是在set里找不到此时的a[i]，那么它就是关键数放入key数组中，最后输出key数组即可。(se.find(a[i]) == se.end())代表set里面找不到。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; se;int main() &#123; int n, t; cin &gt;&gt; n; int a[n + 5] = &#123;0&#125;, key[n + 5] = &#123;0&#125;; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; ++i) &#123; t = a[i]; while (t != 1) &#123; if (t &amp; 1) &#123; t = (3 * t + 1) / 2; se.insert(t); &#125; else &#123; t /= 2; se.insert(t); &#125; &#125; &#125; sort(a, a + n); int ret = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; if (se.find(a[i]) == se.end()) key[ret++] = a[i]; &#125; for (int i = 0; i &lt; ret; ++i) &#123; if (i != ret - 1) &#123; cout &lt;&lt; key[i] &lt;&lt; " "; &#125; else &#123; cout &lt;&lt; key[i] &lt;&lt; endl; &#125; &#125; return 0;&#125; 1006 换个格式输出整数原题链接 分析：用a,b,c分别存储百、十、个的个数然后循环输出即可。 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int a = n / 100; int b = n / 10 % 10; int c = n % 10; for (int i = 0; i &lt; a; i++) cout &lt;&lt; "B"; for (int i = 0; i &lt; b; i++) cout &lt;&lt; "S"; for (int i = 0; i &lt; c; i++) cout &lt;&lt; i + 1; return 0;&#125; 1007 素数对猜想原题链接 分析：直接素数打表，然后如果prime[i]和prime[i + 2]都是素数的话sum++。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 5;bool prime[MAXN + 5];int sum = 0, n;void Prime() &#123; for (int i = 2; i &lt;= MAXN; i++) prime[i] = true; for (int i = 2; i * i &lt;= MAXN; i++) &#123; if (prime[i]) &#123; for (int j = i * i; j &lt;= MAXN; j += i) prime[j] = false; &#125; &#125; for (int i = 2; i &lt;= MAXN; i++) &#123; if (prime[i] &amp;&amp; prime[i + 2]) &#123; if (i + 2 &gt; n) break; sum++; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123; cin &gt;&gt; n; Prime(); return 0;&#125; 1008 数组元素循环右移问题原题链接 分析：调用list模拟题目过程。back() 返回最后一个元素front() 返回第一个元素pop_back() 删除最后一个元素pop_front() 删除第一个元素push_back() 在list的末尾添加一个元素push_front() 在list的头部添加一个元素需要注意的是类似pop_back()这种是没有返回值的，java是有的，在c++里要想获得头部元素或者尾部元素只能用back()和front()。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;list&lt;int&gt; ls;int main() &#123; int n, m, t; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; t; ls.push_back(t); &#125; while (m--) &#123; t = ls.back(); ls.pop_back(); ls.push_front(t); &#125; t = 0; while (ls.size() &gt; 0) &#123; if (t == 0) cout &lt;&lt; ls.front(); else cout &lt;&lt; " " &lt;&lt; ls.front(); t = 1; ls.pop_front(); &#125; return 0;&#125; 1009 说反话原题链接分析：用cin接收每个单词，放入vector中，然后逆序输出vector即可。 输入结束时，在OJ里面会在输入文件结束后自动结束，如果是在IDE里面测试，会需要按ctrl + d手动结束输入；Java的话用好nextLine和split即可。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;string&gt; v; string s = ""; while (cin &gt;&gt; s) v.push_back(s); for (int i = v.size() - 1; i &gt;= 0; --i) &#123; if (i == v.size() - 1) &#123; cout &lt;&lt; v[i]; continue; &#125; cout &lt;&lt; " " &lt;&lt; v[i]; &#125; system("pause"); return 0;&#125; 12345678910111213import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); String str = cin.nextLine(); String[] words = str.split(" "); for (int i = words.length - 1; i &gt;= 0; i--) &#123; if (i != 0) System.out.print(words[i] + " "); else System.out.println(words[i]); &#125; &#125;&#125; 1010 一元多项式求导原题链接 分析：每次对输入的两个数进行计算，记得考虑输入的只是常数项的情况，这个时候是要输出”0 0”的 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; bool ok = false; int a, b; while (cin &gt;&gt; a &gt;&gt; b) &#123; if (b != 0) &#123; if (ok) cout &lt;&lt; " "; cout &lt;&lt; a * b &lt;&lt; " " &lt;&lt; b - 1; ok = true; &#125; &#125; if (!ok) cout &lt;&lt; "0 0"; return 0;&#125; 1011 A+B 和 C原题链接 分析：用long long int存储a、b和c，当a + b &gt; c的时候输出true，否则输出false 123456789101112#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main() &#123; ll n, a, b, c; scanf("%lld", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%lld%lld%lld", &amp;a, &amp;b, &amp;c); printf("Case #%d: %s\n", i + 1, a + b &gt; c ? "true" : "false"); &#125; return 0;&#125; 1012 数字分类原题链接 分析：按题意模拟即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int a[1005];int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; int a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0, x = 0, ret = 1; bool ok1 = false, ok2 = false, ok3 = false, ok4 = false, ok5 = false; for (int i = 0; i &lt; n; ++i) &#123; if (a[i] % 5 == 0 &amp;&amp; !(a[i] &amp; 1)) &#123; ok1 = true; a1 += a[i]; &#125; if (a[i] % 5 == 1) &#123; ok2 = true; a2 += (a[i] * ret); ret *= -1; &#125; if (a[i] % 5 == 2) &#123; ok3 = true; a3++; &#125; if (a[i] % 5 == 3) &#123; ok4 = true; x += a[i]; a4++; &#125; if (a[i] % 5 == 4) &#123; ok5 = true; a5 = max(a5, a[i]); &#125; &#125; if (ok1) cout &lt;&lt; a1 &lt;&lt; " "; else cout &lt;&lt; "N "; if (ok2) cout &lt;&lt; a2 &lt;&lt; " "; else cout &lt;&lt; "N "; if (ok3) cout &lt;&lt; a3 &lt;&lt; " "; else cout &lt;&lt; "N "; if (ok4) printf("%.1f ", x * 1.0 / a4); else cout &lt;&lt; "N "; if (ok5) cout &lt;&lt; a5; else cout &lt;&lt; "N"; return 0;&#125; 1013 数素数原题链接 分析：素数打表，a数组存素数的值，用cnt标记输出了多少个，如果当前已经输出的个数为10，将cnt置为1。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int n, m;const int N = 1e6;bool prime[N + 5];int a[N + 5];void Prime() &#123; for (int i = 2; i &lt;= N; ++i) prime[i] = true; for (int i = 2; i * i &lt;= N; ++i) &#123; if (prime[i]) &#123; for (int j = i * i; j &lt;= N; j += i) prime[j] = false; &#125; &#125; int ret = 1; for (int i = 2; i &lt;= N; ++i) &#123; if (prime[i]) a[ret++] = i; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; Prime(); int cnt = 1; for (int i = n; i &lt;= m; ++i) &#123; if (i == m) &#123; cout &lt;&lt; a[i] &lt;&lt; endl; &#125; else if (cnt != 10) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; cnt++; &#125; else &#123; cout &lt;&lt; a[i] &lt;&lt; endl; cnt = 1; &#125; &#125; return 0;&#125; 1014 福尔摩斯的约会原题链接 分析：按照题意找到相等的字符后判断即可，如果输出的时间不足2位数要在前面添0，即用%02d输出。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;string day[] = &#123;"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"&#125;;int main() &#123; string s1 = "", s2 = "", s3 = "", s4 = ""; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4; int a = -1, b = -1, c = -1, i, j; for (i = 0; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); ++i) &#123; if (s1[i] == s2[i] &amp;&amp; (s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'G')) &#123; a = s1[i] - 'A'; break; &#125; &#125; i++; for (; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); ++i) &#123; if (s1[i] == s2[i] &amp;&amp; ((s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'N') || isdigit(s1[i]))) &#123; b = isdigit(s1[i]) ? s1[i] - '0' : s1[i] - 'A' + 10; break; &#125; &#125; for (j = 0; j &lt; s3.length() &amp;&amp; j &lt; s4.length(); ++j) &#123; if (s3[j] == s4[j] &amp;&amp; isalpha(s3[j])) &#123; c = j; break; &#125; &#125; cout &lt;&lt; day[a] &lt;&lt; " "; printf("%02d:%02d", b, c); return 0;&#125; 1015 德才论原题链接 分析：首先用结构体存储准考证号、德分、才分，再根据题意写好cmp函数，结构体数组vector v[4]中v[0]保存第一类考生，v[1]保存第二类考生，最后依次sort之后遍历这四个vector输出答案即可。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int id, de, cai;&#125; nd;bool cmp(node x, node y) &#123; if ((x.de + x.cai) == (y.de + y.cai)) &#123; if (x.de == y.de) return x.id &lt; y.id; return x.de &gt; y.de; &#125; return (x.de + x.cai) &gt; (y.de + y.cai);&#125;int main() &#123; int n, low, high, num = 0; scanf("%d%d%d", &amp;n, &amp;low, &amp;high); vector&lt;node&gt; v[4]; num = n; for (int i = 0; i &lt; n; ++i) &#123; scanf("%d%d%d", &amp;nd.id, &amp;nd.de, &amp;nd.cai); if (nd.de &lt; low || nd.cai &lt; low) &#123; num--; &#125; else if (nd.de &gt;= high &amp;&amp; nd.cai &gt;= high) &#123; v[0].push_back(nd); //才德全尽 &#125; else if (nd.de &gt;= high &amp;&amp; nd.cai &lt; high) &#123; v[1].push_back(nd); //德胜才 &#125; else if (nd.de &lt; high &amp;&amp; nd.cai &lt; high &amp;&amp; nd.de &gt;= nd.cai) &#123; v[2].push_back(nd); //“才德兼亡”但尚有“德胜才” &#125; else &#123; v[3].push_back(nd); &#125; &#125; printf("%d\n", num); for (int i = 0; i &lt; 4; ++i) &#123; sort(v[i].begin(), v[i].end(), cmp); for (int j = 0; j &lt; v[i].size(); ++j) &#123; printf("%d %d %d\n", v[i][j].id, v[i][j].de, v[i][j].cai); &#125; &#125; return 0;&#125; 1016 部分A+B原题链接 分析：A和B用字符串存储，模拟即可。 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string a, b; int da, db, pa = 0, pb = 0; cin &gt;&gt; a &gt;&gt; da &gt;&gt; b &gt;&gt; db; for (int i = 0; i &lt; a.length(); i++) &#123; if (da == (a[i] - '0')) pa = pa * 10 + da; &#125; for (int i = 0; i &lt; b.length(); i++) &#123; if (db == (b[i] - '0')) pb = pb * 10 + db; &#125; cout &lt;&lt; pa + pb &lt;&lt; endl; return 0;&#125; 1019 数字黑洞原题链接 分析：用数组存储每一位，然后每次对得到的n分给数组的每一位，sort一下，用y存储大的，用x存储小的，若y - x == 6174就break即可。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int a[4];int main() &#123; int n, x, y; cin &gt;&gt; n; while (n != 0) &#123; memset(a, 0, sizeof(a)); a[0] = n / 1000, a[1] = n / 100 % 10, a[2] = n / 10 % 10, a[3] = n % 10; //千百十个 sort(a, a + n); x = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3]; y = a[3] * 1000 + a[2] * 100 + a[1] * 10 + a[0]; n = y - x; printf("%04d - %04d = %04d\n", y, x, n); if (n == 6174) break; &#125; return 0;&#125; 1020 月饼原题链接 分析：简单贪心，要想收益最大，那么我们需要优先卖出单价高的月饼，所以我们自定义cmp以单价从大到小排序，然后从1~n遍历，如果此时月饼的库存&lt;=最大需求量，那么收益+=这款月饼的总售价，否则收益+=需求量*单价。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; double stock, value, unit;&#125; ck[1005];bool cmp(node x, node y) &#123; return x.unit &gt; y.unit; &#125;int main() &#123; int n, d; cin &gt;&gt; n &gt;&gt; d; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; ck[i].stock; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; ck[i].value; for (int i = 0; i &lt; n; ++i) ck[i].unit = ck[i].value * 1.0 / ck[i].stock; sort(ck, ck + n, cmp); double revenue = 0.0; for (int i = 0; i &lt; n; ++i) &#123; if (ck[i].stock &lt;= d) &#123; revenue += ck[i].value; d -= ck[i].stock; &#125; else &#123; revenue += ck[i].unit * d; break; &#125; &#125; printf("%.2lf\n", revenue); return 0;&#125; 1021 个位数统计原题链接 分析：用数组存每一位出现的次数即可，类似桶排序。 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int a[10];int main() &#123; string s; cin &gt;&gt; s; for (int i = 0; i &lt; s.length(); ++i) a[s[i] - '0']++; for (int i = 0; i &lt; 10; ++i) &#123; if (a[i]) cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; a[i] &lt;&lt; endl; &#125; return 0;&#125; 1022 D进制的A+B原题链接 分析：模拟进制转换的过程，首先如果t是0那么直接输出，否则当t != 0时，将每一次t % d的结果保存在ans数组里，然后t /= d，然后逆序输出ans数组即可；JAVA的话用Integer.toString(a,b)即可，将 int 转换为 String，以 b 为进制。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int ans[1005];int main() &#123; int a, b, d, t = 0; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; t = a + b; if (t == 0) &#123; cout &lt;&lt; 0; return 0; &#125; int cnt = 0; while (t != 0) &#123; ans[cnt++] = t % d; t /= d; &#125; for (int i = cnt - 1; i &gt;= 0; --i) cout &lt;&lt; ans[i]; return 0;&#125; 12345678910111213import java.io.BufferedInputStream;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(new BufferedInputStream(System.in)); int a = cin.nextInt(); int b = cin.nextInt(); int c = cin.nextInt(); String str = Integer.toString(a + b, c); System.out.println(str); &#125;&#125; 1023 组个最小数原题链接 分析：简单贪心，先输出一个最小的数字，并将这个数字用t保存，0除外，然后在输出a[0]个0，以及t数字剩下的个数，以及t后面的所有数字即可。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int a[10];int main() &#123; int t = 0; for (int i = 0; i &lt; 10; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt; 10; ++i) &#123; if (a[i] != 0) &#123; cout &lt;&lt; i; t = i; break; &#125; &#125; for (int i = 0; i &lt; a[0]; ++i) cout &lt;&lt; 0; for (int i = 0; i &lt; a[t] - 1; ++i) cout &lt;&lt; t; for (int i = t + 1; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; a[i]; ++j) cout &lt;&lt; i; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT 1054 求平均值]]></title>
    <url>%2F2019%2F07%2F23%2FPAT-1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。 输入格式：输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。 输出格式：对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。 输入样例 1：75 -3.2 aaa 9999 2.3.4 7.123 2.35 输出样例 1：ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38 输入样例 2：2aaa -9999 输出样例 2：ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined 记录一下：sscanf() – 从一个字符串中读进与指定格式相符的数据即把字符数组a中的内容以”%lf”的格式写道temp中，从左至右sprintf() – 字符串格式化命令，主要功能是把格式化的数据写入某个字符串中。即把temp以”%.2lf”的形式写到b字符数组中，从右至左 思路：可以用JAVA异常处理比较方便，c++的话就直接判断 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;// sscanf() – 从一个字符串中读进与指定格式相符的数据,//把字符数组a中的内容以"%lf"的格式写道temp中，从左至右// sprintf() – 字符串格式化命令，主要功能是把格式化的数据写入某个字符串中。//把temp以"%.2lf"的形式写到b字符数组中，从右至左int main() &#123; int n, cnt = 0; char a[50], b[50]; double temp, sum = 0.0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; scanf("%s", a); sscanf(a, "%lf", &amp;temp); sprintf(b, "%.2f", temp); int ok = 0; for (int j = 0; j &lt; strlen(a); j++) &#123; if (a[j] != b[j]) &#123; ok = 1; break; &#125; &#125; if (ok || temp &lt; -1000 || temp &gt; 1000) &#123; printf("ERROR: %s is not a legal number\n", a); &#125; else &#123; sum += temp; cnt++; &#125; &#125; if (cnt == 1) &#123; printf("The average of 1 number is %.2f", sum); &#125; else if (cnt &gt; 1) &#123; printf("The average of %d numbers is %.2f", cnt, sum * 1.0 / cnt); &#125; else &#123; printf("The average of 0 numbers is Undefined"); &#125; system("pause");&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner; public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int cnt = 0; double y = 0; for (int i = 0; i &lt; n; i++) &#123; double x = 0; String s = null; try &#123; s = in.next(); x = Double.parseDouble(s); double temp = Double.parseDouble(String.format("%.2f", x)); if (x &gt; 1000 || x &lt; -1000 || Math.abs(temp - x) &gt;= 0.001) &#123; throw new NumberFormatException(); &#125; cnt++; y += x; &#125; catch (NumberFormatException e) &#123; System.out.println("ERROR: " + s + " is not a legal number"); &#125; &#125; in.close(); if (cnt == 0) &#123; System.out.println("The average of 0 numbers is Undefined"); &#125; else if (cnt == 1) &#123; System.out.printf("The average of 1 number is %.2f", y); &#125; else &#123; System.out.printf("The average of %d numbers is %.2f", cnt, y / cnt); &#125; &#125; &#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT 1052 卖个萌]]></title>
    <url>%2F2019%2F07%2F23%2FPAT-1052-%E5%8D%96%E4%B8%AA%E8%90%8C%2F</url>
    <content type="text"><![CDATA[题目萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的： [左手] ([左眼][口][右眼]) [右手] 现给出可选用的符号集合，请你按用户的要求输出表情。 输入格式：输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 [ ]内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。 之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。 输出格式：对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @/@。 输入样例：[╮][╭][o][][/] [&lt;][&gt;] [╯][╰][^][-][=][&gt;][&lt;][@][⊙][Д][▽][_][ε][^] …41 1 2 2 26 8 1 5 53 3 4 3 32 10 3 9 3 输出样例：╮(╯▽╰)╭&lt;(@Д=)/~o(^ε^)oAre you kidding me? @/@ 思路：因为不知道一行有多少个表情，所以用一个string类型的不定长二维数组vector存储表情包，以及可以调用v.size()顺便解决不知道一行有多少个表情的问题不定长数组共三行，分别对应输入用例的三行，只不过在存储如数组之前把它们的方括号去掉在存储，这里可以用string的substr方法实现然后根据输入的数字序号输出对应的表情注意：1.“Are you kidding me? @/@”的’\’是转义字符，想要输出’\’就要用’\’表示，‘%’也是同理，要想输出需要‘%%’才可以2.第一个测试点里面包含了空格，所以用cin会失败的，要用getline才能读入一行字符串 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; vector&lt;vector&lt;string&gt; &gt; v;//string v[10][10]; for (int i = 0; i &lt; 3; ++i) &#123; string s; getline(cin, s); vector&lt;string&gt; v1;//string v1[10]; for (int j = 0, k = 0; j &lt; s.length(); ++j) &#123; if (s[j] == '[') &#123; while (k++ &lt; s.length()) &#123; if (s[k] == ']') &#123; v1.push_back(s.substr(j + 1, k - j - 1)); break; &#125; &#125; &#125; &#125; v.push_back(v1); &#125; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; int a, b, c, d, e; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; if (a &gt; v[0].size() || b &gt; v[1].size() || c &gt; v[2].size() || d &gt; v[1].size() || e &gt; v[0].size() || a &lt; 1 || b &lt; 1 || c &lt; 1 || d &lt; 1 || e &lt; 1) &#123; cout &lt;&lt; "Are you kidding me? @\\/@" &lt;&lt; endl; continue; &#125; cout &lt;&lt; v[0][a - 1] &lt;&lt; "(" &lt;&lt; v[1][b - 1] &lt;&lt; v[2][c - 1] &lt;&lt; v[1][d - 1] &lt;&lt; ")" &lt;&lt; v[0][e - 1] &lt;&lt; endl; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1050 螺旋矩阵]]></title>
    <url>%2F2019%2F07%2F23%2FPAT-1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。 输入格式：输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 10^4，相邻数字以空格分隔。 输出格式：输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 输入样例：12 37 76 20 98 76 42 53 95 60 81 58 93 输出样例：98 95 9342 37 8153 20 7658 60 76 思路：这题单纯只是想记录下找出N的两个差值最小的约数，即sqrt（N）前后的两个数,大的为m,小的为n即可，螺旋矩阵就直接按右、下、左、上模拟即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;int cmp(int x, int y) &#123; return x &gt; y; &#125;int main() &#123; int N, c, r; cin &gt;&gt; N; for (r = sqrt(N); r &gt;= 1; r--) &#123; if (N % r == 0) &#123; c = N / r; break; &#125; &#125; int a[N + 5], b[c + 5][r + 5]; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i = 0; i &lt; N; ++i) cin &gt;&gt; a[i]; sort(a, a + N, cmp); b[0][0] = a[0]; int t = 0, x = 0, y = 0; while (t &lt; r * c) &#123; while (y + 1 &lt; r &amp;&amp; !b[x][y + 1]) &#123; y++, t++; b[x][y] = a[t]; &#125; while (x + 1 &lt; c &amp;&amp; !b[x + 1][y]) &#123; x++, t++; b[x][y] = a[t]; &#125; while (y - 1 &gt;= 0 &amp;&amp; !b[x][y - 1]) &#123; y--, t++; b[x][y] = a[t]; &#125; while (x - 1 &gt;= 0 &amp;&amp; !b[x - 1][y]) &#123; x--, t++; b[x][y] = a[t]; &#125; &#125; for (int i = 0; i &lt; c; ++i) &#123; for (int j = 0; j &lt; r; ++j) &#123; if (j == r - 1) printf("%d\n", b[i][j]); else printf("%d ", b[i][j]); &#125; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT 1049 数列的片段和]]></title>
    <url>%2F2019%2F07%2F23%2FPAT-1049-%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。 给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。 输入格式：输入第一行给出一个不超过 10^5的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。 输出格式：在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。 输入样例：4 0.1 0.2 0.3 0.4 输出样例：5.00 思路：第一次直接模拟，结果直接超时，后来发现可以推公式，即先算出右边包括其本身出现的次数，是n-i，那么他左边的次数就是i+1，比如3之前有1、2，那么2 * 右边的次数 * a[i] 就是ans，因为对于1可以和右边的3，（3，4）组合即，123，1234，2也可以组成23，234，所以排列组合得ans = 左边的个数 * 右边的个数 * a[i]; 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;double a[100005];int main() &#123; int n; scanf("%d", &amp;n); double sum = 0.00; for (int i = 0; i &lt; n; ++i) &#123; scanf("%lf", &amp;a[i]); sum += (i + 1) * a[i] * (n - i); &#125; //先算出右边包括其本身出现的次数，是n-i，那么他左边的次数就是i+1，比如3之前有1、2，那么2*右边的次数*a[i]就是大小， //因为对于1可以和右边的3，（3，4）组合即，123，1234，2也可以组成23，234， //所以排列组合得ans=左边的个数*右边的个数*a[i]; // for (int i = 0; i &lt; n; ++i) &#123; //每次选一个数 // for (int j = 0; j &lt; n - i; ++j) &#123; //一个数、两个数、三个数... // for (int k = i; k &lt; n - j; ++k) &#123; //累加 // sum += a[k]; // &#125; // &#125; // &#125;TLE printf("%.2lf\n", sum); system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络 学习笔记]]></title>
    <url>%2F2019%2F07%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、概述 三网：电信网络，有线电视网络，计算机网络 Internet：因特网 internet：互联网/互连网 在网络核心部分起特殊作用的是路由器，路由器转发收到的分组就是实现分组交换。 两类通信方式： 客户-服务器模式（C/S）: 客户是服务的请求方，服务器是服务的提供方 客户程序： 1. 客户程序被用户调用后，在通信时主动向远地服务器发起通信请求服务，因此，客户程序必须知道服务器的地址 2. 不需要特殊的硬件以及复杂的操作系统。 服务器程序： 1. 服务器程序是一种专门用来提供服务的程序，可同时处理多个远地或本地客户的请求。 2.系统启动后一直不断地运行着，被动地等待并接受来自各地用户的请求。因此，服务器程序不需要知道客户程序的地址 对等连接方式（P2P）：表示两个主机在通信时并不区分哪一个是服务请求方还是服务提供方，是对等的连接通信。即既是客户端又是服务端。 点到点：相邻结点之间的通信，中间无中转站 端到端：终端到终端，中间有很多结点 总的来说就是端到端就是由无数的点到点组成和实现的。 试比较三种主要交换技术的优缺点。 1.电路交换：在数据传输之前必须设置一条专用的物理通路，在通话的全部时间内，通话的两个用户始终占用端到端的通信资源。优点是快速、可靠、保序、适用于连续传送大量数据。缺点就是传送计算机数据时线路的传输效率往往很低。 2.报文交换：不需要预先分配传输带宽，动态逐段利用传输带宽对突发式数据通信效率高，通信迅速。缺点是存储转发造成的时延较长。 3.分组交换：把报文分割成固定长度的分组，采用“存储转发”原理传输，经路由器储存转发，到达目标结点后重新组装成报文并且不需要预先分配传输带宽，优点是高效、灵活、迅速、可靠，缺点是存储转发会造成时延，分组必须携带的首部造成一定的开销。 例. 试在下列条件下比较电路交换和分组交换。要传送的报文共x（bit）。从源点到终点共经过k段链路，每段链路的传播时延为d（s），数据率为b(b/s)。在电路交换时电路的建立时间为s(s)。在分组交换时分组长度为p(bit)，且各结点的排队等待时间可忽略不计。问在怎样的条件下，分组交换的时延比电路交换的要小？（提示：画一下草图观察k段链路共有几个结点。） 答：线路交换时延：kd+x/b+s, 分组交换时延：kd+(x/p)(p/b)+ (k-1)(p/b)，其中(k-1)(p/b)表示K段传输中，有(k-1)次的储存转发延迟，当s&gt;(k-1)(p/b)时，电路交换的时延比分组交换的时延大，当x&gt;&gt;p,相反。 主机是为用户进行信息处理的，路由器则是对分组进行存储转发，即进行分组交换 早期的面向终端的计算机网络是以单个主机为中心的星形网分组交换网则是以网络为中心，主机都处在网络的外围 按作用范围：WAN(广域网），MAN（城域网），LAN（局域网），PAN（个人区域与网）； 计算机网络的性能指标：速率，带宽，吞吐量，时延，时延带宽积，往返时间，利用率对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率，提高数据的发送速率只是减小了数据的发送时延D = D0/(1-U)，U为利用率，D为时延，因此利用率不是越高越好。减少方法：增大线路的带宽。总时延 = 发送时延 + 传送时延 + 处理时延 + 排队时延 计算机网络的非性能指标：费用，质量，标准化，可靠性，可扩展性和可升级性，易于管理和维护 协议分层的好处：1.各层之间是相互独立的；2.灵活性好；3.结构上可分隔开；4.易于实现和维护；5.能促进标准化工作 ATM:异步传输模式 组成网络协议的三要素是语义、语法、定时 五层体系结构的功能： 1.物理层：物理层的功能就是透明地传送比特流。 2.数据链路层：数据链路层的功能是在两个相邻结点间的线路上无差错地传送以帧为单位的数据。//传输单位：帧，最短为64字节 3.网络层：网络层的功能就是要选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。 4.运输层：运输层的功能是向上一层的进行通信的两个进程之间提供一个可靠的端到端服务。//传输单位：报文段 5.应用层：应用层的功能直接为用户的应用进程提供服务。//传输单位：报文]]></content>
      <categories>
        <category>专业课相关</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数值分析 学习笔记]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Chapter 1 误差误差：模型误差，观测误差，截断误差(方法误差)，舍入误差//前两种不可避免总误差＝截断误差＋舍入误差\由于相对误差可以很大，因此“应避免两个相近的数作减法”，以防止有效数字丢失。//所以遇到分式减法需要优化就通分，例1.4应避免接近于零的数作分母，并避免大的数作乘法.]]></content>
      <categories>
        <category>专业课相关</category>
      </categories>
      <tags>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓入门 学习笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%AE%89%E5%8D%93%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JDK + android studio安装JDK和环境变量的配置；最新的android studio要求至少JDK1.8以上去官网下载最新版本的android studio；SDK可以下载android studio之后去settings里下载； SDK Software Development Kit, 软件开发工具包 NDK Native Development Kit, 安卓原生开发工具包 hello world工程目录结构 src JAVA源代码目录，放置JAVA的源代码R.java 定义与res文件下资源相对应的iddrawable 图像资源values 值资源（字符串资源、风格资源等）layout 布局资源AndroidManifest.xml 核心配置文件，界面、服务等组件配置，每生成一个activity都要在这里注册 hello world详解 创建工程，生成MainActivity类，继承自Activity类onCreate方法：设置内容视图，在当前页面被创建时展现布局setContentView：展示布局（就是把xml布局文件部署到当前页面）\ 12345678import androidx.appcompat.app.AppCompatActivity;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.appcompat.widget.LinearLayoutCompat xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/androidx.appcompat.widget.LinearLayoutCompat&gt; Activity（可视化交互界面） layout中定义的布局都会在Activity中进行显示操作系统→Manifest→Activity→setContentView调用xml布局通过Activity.java动态修改layout控件findViewById: 通过R.java中定义的id找到view View 通过获取View来控制对象给View添加一个id,view = findViewById(R.id.ID);调用.set方法来修改对象的属性： view.setText(“hello KYZ”); 使用监听器进行交互实现监听器接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import androidx.appcompat.app.ActionBar;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.net.Uri;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.EditText;import android.widget.ImageView;import android.widget.ProgressBar;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private SharedPreferences sharedPreferences; private ImageView imageView; private ProgressBar progressBar; private ActionBar actionBar; private CheckBox remember; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); userid = (EditText) findViewById(R.id.edit_text1); password = (EditText) findViewById(R.id.edit_text2); imageView = (ImageView) findViewById(R.id.image_view); actionBar = getSupportActionBar(); if (actionBar != null) actionBar.hide(); Button pedit = (Button) findViewById(R.id.edit); pedit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("https://im.qq.com/")); startActivity(intent); &#125;//进网址 &#125;); Button pback = (Button) findViewById(R.id.back); pback.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this, "You clicked the back button", Toast.LENGTH_SHORT).show(); &#125;//当点击按钮出现Toast弹窗 &#125;); Button register = (Button) findViewById(R.id.id1); register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("https://im.qq.com/")); startActivity(intent); &#125; &#125;); Button login = (Button) findViewById(R.id.id2); login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (userid.getText().toString().equals("KYZ") &amp;&amp; password.getText().toString().equals("******")) &#123; Intent intent = new Intent(MainActivity.this, menuTest.class); startActivity(intent); &#125; else &#123; Toast.makeText(MainActivity.this, "您的账号或密码错误", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); getSharePreferece(); remember = (CheckBox) findViewById(R.id.remember_pass); remember.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; userin = userid.getText().toString(); passwo = password.getText().toString(); setSharePreferece(); &#125; &#125;); &#125; layout布局 Linear Layout和Relative Layout，线性布局和相对布局xml布局文件、Java代码oriandroid:orientation=”vertical” 垂直分布 horizontal 水平分布gravity 当前内容与控件对齐方式layout_gravity 与父控件的对齐方式match_parent 填充父控件wrap_content 适应内容padding 内容与控件边界的距离margin 控件相对于控件的距离weight ：注意设置宽度/高度为0dppx：像素dp：设备独立像素，给控件设置宽高sp：字体会跟随系统设置变化，给内容设置大小 UI基础TextView属性 id “@id/ID”，引用已有ID， “@+id/ID”，创建新IDbackground “#00ffff” “@color/COLOR”引用已有COLORbackground “@drawable/picture” （JPG小，但不可显示透明色，PNG大）string 引用stringtextSize:”15sp” textColor:”@color/COLOR”autoLink:” web / email / phone / map “ 链接drawableLeft 给控件周围添加图片singleLine 单行显示内容ellipsize 剩余内容如何显示（省略号，跑马灯等）textStyle 字体风格，正常、粗体、斜体typeface 字体类型，（美工相关） 匿名内部类相较于成员内部类而言，直接在对button进行setOnClickListener对象的时候new一个匿名对象，然后重写Onclick即可。 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);//装载xml布局 bt = findViewById(R.id.button2);//获取button对象 bt.setOnClickListener( new View.OnClickListener() &#123;//匿名内部类 @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this,"hello KYZ!",Toast.LENGTH_LONG).show(); //LENGTH_LONG弹窗时间长一些，LENGTH_SHORT时间段短些 &#125; &#125;);&#125; EditText inputType 设置输入文本类型 textPassword(密码)text 默认内容hint 提示内容maxLength 最长长度ImageView ImageButton（带背景图的可视控件）src 导入前景图片scaleType 填充类型 center / centercrop / centerinside等CheckBox 多选按钮CheckBox监听器内部类 保存密码12345678910111213141516171819private final String filename = "login.xml";private String userin, passwo;private EditText userid, password;public void setSharePreferece() &#123; sharedPreferences = getSharedPreferences(filename, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putString("账号", userin); editor.putString("密码", passwo); editor.commit();&#125;public void getSharePreferece() &#123; sharedPreferences = getSharedPreferences(filename, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); userin = sharedPreferences.getString("账号", ""); userid.setText(userin); passwo = sharedPreferences.getString("密码", ""); password.setText(passwo);&#125;]]></content>
      <categories>
        <category>安卓学习</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1308 比赛]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1308-%E6%AF%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[题目描述有n个人要进行比赛，比赛规则如下：假设每轮比赛的人是m，取最大的k，k=2t且k≤m。这k个人每2人举行一场比赛，胜利者进入一下轮，失败者被淘汰。余下的m-k个人，不进行比赛，直接进入下一轮直到决出冠军，比赛结束。比如有5个人参加比赛，第一轮举办2场，剩余3人进入第二轮，第二轮1场，剩余2人进入第三轮，第三轮举办1场决出冠军，所以一共要办4场比赛。 请问一共要举行几轮多少场比赛？ 输入第一行是一个整数K，表示样例的个数。 以后每行一个样例，为n(1≤n≤1000000000) 输出每行输出两个整数，轮数和比赛场数，中间用一个空格隔开。 样例输入2 1 5 样例输出0 0 3 4 思路：直接按题意模拟即可 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; ll n; scanf("%I64d", &amp;n); ll lun = 0, chang = 0; while (n &gt; 1) &#123; ll k = 1; while (k &lt;= n) &#123; //求k if (k * 2 &gt; n) break; k *= 2; &#125; n -= k; k /= 2; //场次 chang += k; lun++; n += k; &#125; printf("%I64d %I64d\n", lun, chang); &#125; system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1296 GCD]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1296-GCD%2F</url>
    <content type="text"><![CDATA[题目描述a和b的最大公约数(Greatest Common Divisor)是最大的d，d能整除a和b。如果gcd(a,b)=1，我们就称a和b是互素的。 给一个区间[a,b]，求与6互素的数的个数。比如区间[1,10],与6互素的数为1,5,7,所以一共是3个。 输入第一行是一个整数K(K≤10,000)，表示样例的个数。每个样例占一行,为区间[a,b],(1≤a≤b≤1,000,000,000) 输出每行输出一个样例的结果 样例输入21 101 1000000000 样例输出3333333333 思路：容斥，与6互素就不会有和6一样的因子2,3，所以[l,r]区间的数减去2和3的倍数再加上6的倍数(计算2和3的倍数时多减了一次)即为答案，另外对于大数判断倍数遍历判断是肯定会超时的，有个思路就是就是 1 到 n 有多少个是 m 倍数，个数为 n/m。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a, b;int main() &#123; int k; scanf("%d", &amp;k); while (k--) &#123; scanf("%lld%lld", &amp;a, &amp;b); ll l = (b * 1.0 / 2) - (a - 1) * 1.0 / 2; ll r = (b * 1.0) / 3 - (a - 1) * 1.0 / 3; ll lr = b - a + 1; ll sum = (b * 1.0) / 6 - (a - 1) * 1.0 / 6; sum = lr - l - r + sum; printf("%lld\n", sum); &#125;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1294 Enquiry]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1294-Enquiry%2F</url>
    <content type="text"><![CDATA[题目描述男女同学排成一列，你想知道第i个到第j个同学之间，男女相邻排列的出现次数。 输入第一行是一个整数K，表示样例的个数。每个样例的第一行是一个字符串s，其长度len不超过10000，只含字符M和F，M表示男生，F表示女生。每个样例的第二行是一个整数n(1≤n≤1000)，表示查询的次数。以后的N行,每行两个整数i,j(1≤i&lt;j≤len)，表示查询的区间。 输出每个样例的每次查询输出一个整数。 样例输入2MMMMM31 21 31 5MFMFM31 52 33 5 样例输出000412 思路：维护一个前缀和即可，pre[i]表示1…i有多少男女相邻的个数 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, pre[10005];//维护一个前缀和void presum(string str) &#123; memset(pre, 0, sizeof(pre)); pre[0] = 0; for (int i = 1; i &lt; str.length(); ++i) &#123; if (str[i - 1] != str[i]) pre[i] = 1; pre[i] = pre[i] + pre[i - 1]; &#125;&#125;int main() &#123; int k, a, b; scanf("%d", &amp;k); while (k--) &#123; string s; cin &gt;&gt; s; presum(s); scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", pre[b - 1] - pre[a - 1]); &#125; &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1291 Buying Gifts]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1291-Buying-Gifts%2F</url>
    <content type="text"><![CDATA[题目描述快到年末了，Boss Liu准备在年会上发些礼物，由于不想礼物的价格区别太大，Boss Liu希望最好的礼物与最差的礼物价格相差越小越好。 当然，如果存在相同的选择，Boss Liu希望花的钱越少越好。Boss Liu把这个买礼物的任务给你，你决定写个程序来帮助自己计算一下。 输入第一行是一个整数K，表示样例的个数。每个样例的第一行是一个整数n,m(1≤m≤n≤1000)，分别表示可购买的礼物的个数和实际需要购买的个数。每个样例的第二行是n个整数xi,i=1,2,⋯,n(1≤xi≤100)，表示n个礼物的价格。 输出每个样例输出两个整数，分别表示最小的价差以及总的花费，中间用一个空格隔开。 样例输入25 310 5 9 7 25 110 5 9 7 2\ 样例输出3 260 2 线索第一个样例，购买10,9,7的礼物的差值最小为3，总花费是26。第二个样例，因为只买一样所以差值都是0，最小花费是2。 思路：将价格升序排序后以长度m尺取找出最小价格差即可，由于排好序所以总和肯定取之前的更小 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int x[1005], n, m; //礼物的价格、可购买的个数、实际需要购买的次数int sum(int a) &#123; int ans = 0; for (int i = a; i &lt; m + a; ++i) ans += x[i]; return ans;&#125;int main() &#123; int k; scanf("%d", &amp;k); while (k--) &#123; memset(x, 0, sizeof(x)); scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf("%d", &amp;x[i]); sort(x, x + n); int minv = 100005, spend = 0; for (int i = 0; i &lt; n; ++i) &#123; if (x[m + i - 1] - x[i] &lt; minv) &#123; minv = x[m + i - 1] - x[i]; spend = sum(i); &#125; else if (x[m + i - 1] - x[i] == minv) &#123; spend = min(sum(i), spend); &#125; if (m + i - 1 == n - 1) break; &#125; printf("%d %d\n", minv, spend); &#125;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>尺取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1243 Bob's Password]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1243-Bob-s-Password%2F</url>
    <content type="text"><![CDATA[题目描述Bob最新购入一款安卓手机，他发现安卓手机密码使用的是画线方式。一共有9个点，我们按行列顺序依次为1~9。密码要求在点和点之间连线不能有还未曾经过的点。比如说：从1出发，可以到2，4，5，6，7，8，但是不能到达3，7，9。但是如果从2出发，先到1，这时因为2已经经过了，所以此时可以到达3。现在给你一个密码，请问它是否符合密码的这个要求？ 输入第一行是一个整数T(1≤T≤10000)，表示样例的个数。一个样例占一行，是一个最短为4位，最长9位，只含1-9的字符串，且1-9最多只有1个。 输出每个样例输出一行，如果合法输出“Yes”，否则输出“No”。 样例输入316852213132 样例输出YesYesNo 思路：首先用一个mp数组存储每个点到其它各点的状态，比如对1来说，1-&gt;1是自身不可访问，标记为-1，1-&gt;2可以访问，标记为0，1-&gt;3需要先经过2这个点，标记为2，即2这个点被访问，我们可以用访问数组进行标记，之后根据样例判断即可。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int mp[10][10] = &#123; &#123;-5, -5, -5, -5, -5, -5, -5, -5, -5, -5&#125;, &#123;-5, -1, 0, 2, 0, 0, 0, 4, 0, 5&#125;, &#123;-5, 0, -1, 0, 0, 0, 0, 0, 5, 0&#125;, &#123;-5, 2, 0, -1, 0, 0, 0, 5, 0, 6&#125;, &#123;-5, 0, 0, 0, -1, 0, 5, 0, 0, 0&#125;, &#123;-5, 0, 0, 0, 0, -1, 0, 0, 0, 0&#125;, &#123;-5, 0, 0, 0, 5, 0, -1, 0, 0, 0&#125;, &#123;-5, 4, 0, 5, 0, 0, 0, -1, 0, 8&#125;, &#123;-5, 0, 5, 0, 0, 0, 0, 0, -1, 0&#125;, &#123;-5, 5, 0, 6, 0, 0, 0, 8, 0, -1&#125;&#125;;int vis[10];int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; memset(vis, 0, sizeof(vis)); string s; bool ok = true; cin &gt;&gt; s; vis[s[0] - '0'] = 1; for (int i = 1; i &lt; s.length(); ++i) &#123; if (mp[s[i - 1] - '0'][s[i] - '0'] == 0 ||vis[mp[s[i - 1] - '0'][s[i] - '0']]) &#123; vis[s[i] - '0'] = 1; ok = true; &#125; else &#123; ok = false; break; &#125; &#125; if (ok) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; // system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PAT 1039 到底买不买]]></title>
    <url>%2F2019%2F07%2F19%2FPAT-1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[题目小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。 为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 输入格式：每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 输出格式：如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。 输入样例 1：ppRYYGrrYBR2258YrR8RrY 输出样例 1：Yes 8 输入样例 2：ppRYYGrrYB225YrR8RrY 输出样例 2：No 2 思路：用两个数组分别存储摊主的珠串的个数以及小红想做的珠串的个数，我这里是把[0-9]、[a-z]、[A-Z]都转成数字，方便用数组统计，之后判断如果man[i]&gt;shop[i]，那么就是no，缺少的个数是sum += man[i] + shop[i]，反之若是yes，多余的个数就是sum += shop[i] - man[i]。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int shop[65], man[65];int main() &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; bool ok = true; for (int i = 0; i &lt; s1.length(); ++i) &#123; if (s1[i] &lt;= 'z' &amp;&amp; s1[i] &gt;= 'a') shop[s1[i] - 'a' + 10]++; else if (s1[i] &lt;= 'Z' &amp;&amp; s1[i] &gt;= 'A') shop[s1[i] - 'A' + 36]++; else shop[s1[i] - '0']++; &#125; for (int i = 0; i &lt; s2.length(); ++i) &#123; if (s2[i] &lt;= 'z' &amp;&amp; s2[i] &gt;= 'a') man[s2[i] - 'a' + 10]++; else if (s2[i] &lt;= 'Z' &amp;&amp; s2[i] &gt;= 'A') man[s2[i] - 'A' + 36]++; else man[s2[i] - '0']++; &#125; int sum = 0; for (int i = 0; i &lt; 62; ++i) &#123; if (man[i] &gt; shop[i]) ok = false; &#125; if (ok) &#123; for (int i = 0; i &lt; 62; ++i) sum += shop[i] - man[i]; cout &lt;&lt; "Yes " &lt;&lt; sum &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; 62; ++i) &#123; if (shop[i] &lt; man[i]) sum += man[i] - shop[i]; &#125; cout &lt;&lt; "No " &lt;&lt; sum &lt;&lt; endl; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1271 Color]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1271-Color%2F</url>
    <content type="text"><![CDATA[题目Alice在玩一个游戏，她在一个m×n的格子里，随机涂黑k个格子。然后她每次可以把一行或者一列的格子染成红色，但是这一行中不能有黑色的格子。 请问她最多能把多少个格子涂成红色？ 输入第一行是一个整数T(T≤100)，表示样例的个数。 每个样例的第一行是m(1≤m≤100),n(1≤n≤100),k(0≤k≤m×n)。 以后的k行,每行两个整数x(1≤x≤m),y(1≤y≤n)，表示(x,y)为黑色格子。 输出每行输出一个样例的结果。 样例输入13 4 21 13 3 样例输出8 思路：首先根据x y统计有哪几行哪几列有黑色格子，用row和col数组存储，再对二者遍历可得全为红格子的行数以及红格子的列数，用r和c表示，那么我们可以推出公式ans = r * n + c * m - r * c; 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef long long ll;int row[105], col[105];int main() &#123; int T, m, n, k, x, y; scanf("%d", &amp;T); while (T--) &#123; memset(row, 0, sizeof(row)); memset(col, 0, sizeof(col)); scanf("%d%d%d", &amp;m, &amp;n, &amp;k); while (k--) &#123; scanf("%d%d", &amp;x, &amp;y); row[x - 1] = 1; col[y - 1] = 1; &#125; int r = 0, c = 0; for (int i = 0; i &lt; m; ++i) &#123; if (!row[i]) r++; &#125; for (int i = 0; i &lt; n; ++i) &#123; if (!col[i]) c++; &#125; ll ans = r * n + c * m - r * c; printf("%lld\n", ans); &#125; //system("pause");&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XTU 1262 Fish(优先队列+贪心)]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1262-Fish-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[题目小明很喜欢钓鱼，现在有n个池塘可以钓鱼，第i个池塘首次内能钓到ai条鱼。 第i个池塘如果被钓过k次，那么每次下一次能钓到的鱼的数目为max{0,ai−k×bi}。现在小明能钓m次鱼，请问他最多能钓到多少条鱼？ 输入第一行是一个整数T(1≤T≤100)，表示样例的个数。每个样例的第一行是n(1≤n≤1000),m(1≤m≤100000)；以后的n行，每行是ai(1≤ai≤10000),bi(0≤bi≤10000)。 输出每行输出一个样例的结果。 样例输入23 53 14 21 02 52 11 1 样例输出124 样例解释第一个样例，在第1个池塘钓3次，第2个池塘钓2次，3+2+1+4+2 = 12； 第二个样例，在第1个池塘钓2次，第2个池塘钓1次，2+1+1 = 4。 思路：维护一个优先队列，使价值最高的鱼优先级最高，钓出这种鱼后，从队首弹出这种鱼，改变价值后再压入，这样便能保证每次钓到的鱼都是价值最高的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int a, b, a1, k; //从大到小排列 friend bool operator&lt;(node X, node Y) &#123; return X.a &lt; Y.a; &#125;&#125;;priority_queue&lt;node&gt; pq;// max&#123;0,ai−k×bi&#125;int main() &#123; int T, n, m, a, b; scanf("%d", &amp;T); while (T--) &#123; while (!pq.empty()) pq.pop(); //每次先将队列清空 scanf("%d%d", &amp;n, &amp;m); node nd; while (n--) &#123; scanf("%d%d", &amp;a, &amp;b); nd.a = a; nd.a1 = a; nd.b = b; nd.k = 0; pq.push(nd); &#125; int cnt = 0; while (!pq.empty()) &#123; nd = pq.top(); pq.pop(); if (nd.b != 0) &#123; cnt += nd.a; nd.k++; nd.a = max(0, nd.a1 - nd.k * nd.b); //更新 m--; pq.push(nd); &#125; else &#123; cnt += nd.a * m; //此时数目是当前最多并且不需要更新 m = 0; break; &#125; if (!m) break; &#125; printf("%d\n", cnt); &#125; // system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
