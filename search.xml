<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XTU 1262 Fish(优先队列+贪心)]]></title>
    <url>%2F2019%2F07%2F19%2FXTU-1262-Fish-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[原题链接 http://202.197.224.59/exam/index.php/problem/read/id/1262 题目小明很喜欢钓鱼，现在有n个池塘可以钓鱼，第i个池塘首次内能钓到ai条鱼。 第i个池塘如果被钓过k次，那么每次下一次能钓到的鱼的数目为max{0,ai−k×bi}。现在小明能钓m次鱼，请问他最多能钓到多少条鱼？ 输入第一行是一个整数T(1≤T≤100)，表示样例的个数。每个样例的第一行是n(1≤n≤1000),m(1≤m≤100000)；以后的n行，每行是ai(1≤ai≤10000),bi(0≤bi≤10000)。 输出每行输出一个样例的结果。 样例输入23 53 14 21 02 52 11 1 样例输出124 样例解释第一个样例，在第1个池塘钓3次，第2个池塘钓2次，3+2+1+4+2 = 12； 第二个样例，在第1个池塘钓2次，第2个池塘钓1次，2+1+1 = 4。 思路：维护一个优先队列，使价值最高的鱼优先级最高，钓出这种鱼后，从队首弹出这种鱼，改变价值后再压入，这样便能保证每次钓到的鱼都是价值最高的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int a, b, a1, k; //从大到小排列 friend bool operator&lt;(node X, node Y) &#123; return X.a &lt; Y.a; &#125;&#125;;priority_queue&lt;node&gt; pq;// max&#123;0,ai−k×bi&#125;int main() &#123; int T, n, m, a, b; scanf("%d", &amp;T); while (T--) &#123; while (!pq.empty()) pq.pop(); //每次先将队列清空 scanf("%d%d", &amp;n, &amp;m); node nd; while (n--) &#123; scanf("%d%d", &amp;a, &amp;b); nd.a = a; nd.a1 = a; nd.b = b; nd.k = 0; pq.push(nd); &#125; int cnt = 0; while (!pq.empty()) &#123; nd = pq.top(); pq.pop(); if (nd.b != 0) &#123; cnt += nd.a; nd.k++; nd.a = max(0, nd.a1 - nd.k * nd.b); //更新 m--; pq.push(nd); &#125; else &#123; cnt += nd.a * m; //此时数目是当前最多并且不需要更新 m = 0; break; &#125; if (!m) break; &#125; printf("%d\n", cnt); &#125; // system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>优先队列 贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1039]]></title>
    <url>%2F2019%2F07%2F19%2FPAT1039%2F</url>
    <content type="text"><![CDATA[题目小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。 为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 输入格式：每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 输出格式：如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。 输入样例 1：ppRYYGrrYBR2258YrR8RrY 输出样例 1：Yes 8 输入样例 2：ppRYYGrrYB225YrR8RrY 输出样例 2：No 2 思路：用两个数组分别存储摊主的珠串的个数以及小红想做的珠串的个数，我这里是把[0-9]、[a-z]、[A-Z]都转成数字，方便用数组统计，之后判断如果man[i]&gt;shop[i]，那么就是no，缺少的个数是sum += man[i] + shop[i]，反之若是yes，多余的个数就是sum += shop[i] - man[i]。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int shop[65], man[65];int main() &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; bool ok = true; for (int i = 0; i &lt; s1.length(); ++i) &#123; if (s1[i] &lt;= 'z' &amp;&amp; s1[i] &gt;= 'a') shop[s1[i] - 'a' + 10]++; else if (s1[i] &lt;= 'Z' &amp;&amp; s1[i] &gt;= 'A') shop[s1[i] - 'A' + 36]++; else shop[s1[i] - '0']++; &#125; for (int i = 0; i &lt; s2.length(); ++i) &#123; if (s2[i] &lt;= 'z' &amp;&amp; s2[i] &gt;= 'a') man[s2[i] - 'a' + 10]++; else if (s2[i] &lt;= 'Z' &amp;&amp; s2[i] &gt;= 'A') man[s2[i] - 'A' + 36]++; else man[s2[i] - '0']++; &#125; int sum = 0; for (int i = 0; i &lt; 62; ++i) &#123; if (man[i] &gt; shop[i]) ok = false; &#125; if (ok) &#123; for (int i = 0; i &lt; 62; ++i) sum += shop[i] - man[i]; cout &lt;&lt; "Yes " &lt;&lt; sum &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; 62; ++i) &#123; if (shop[i] &lt; man[i]) sum += man[i] - shop[i]; &#125; cout &lt;&lt; "No " &lt;&lt; sum &lt;&lt; endl; &#125; system("pause");&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
